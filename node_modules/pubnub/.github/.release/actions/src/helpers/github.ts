import * as github from '@actions/github'
import styles from 'ansi-styles'
import path from 'path'
import fs from 'fs'
import {
  GitHubIssues, GitHubPages,
  GitHubPullRequest, GitHubRelease, GitHubRepositoryLabel, GitHubRepositoryLabels, GitHubRepositoryTags,
  OperationOutcome,
  RepositoryLabelsReleaseChangePolicy,
  RepositoryLabelsSet
} from './types'
import {action, getHostnameFromUrl} from './actions'
import {GITHUB_ACTIONS_PATH} from '../constants'
import {Changelog} from '../commands/changelog'
import {GitHubIssue} from './types'
import * as log from './log'

/**
 * Compose email address for GitHub user.
 *
 * @param {string} username GitHub user username.
 *
 * @return {string} Public no-reply email for specified user.
 */
export const emailForUsername = (username: string): string => `${username}@users.noreply.${action.github.hostname}`

/**
 * Modify clone URL, so it can be used to push changes back if required.
 *
 * @param {string} token Token from account, which has at least read access to the repo.
 * @param {string} url HTTPS url to clone target repository.
 */
export const cloneUrl = (token: string, url: string): string => {
  const hostName = getHostnameFromUrl(url)
  return url.replace(hostName, `x-access-token:${token}@${hostName}`)
}

/**
 * Publish comment to specified issue.
 * Required permissions on default GITHUB_TOKEN: 'pull requests' (write)
 *
 * @param {string} owner Owner of repository where target issue has been created.
 * @param {string} repo Name or repository which contains target issue.
 * @param {number} issue GitHub issue / pull request number.
 * @param {string} comment String which should be published to specified issue number.
 *
 * @return {Promise<OperationOutcome>} Asynchronous comment publish results.
 */
export const publishComment = async (
  owner: string,
  repo: string,
  issue: number,
  comment: string
): Promise<OperationOutcome> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const token: string = action.github.ghToken || action.github.token
  let errorMessage, errorSuggestion: string | undefined
  const octokit = github.getOctokit(token)

  try {
    await octokit.request(
      'POST /repos/{owner}/{repo}/issues/{issue_number}/comments',
      {owner, repo, issue_number: issue, body: comment}
    )
  } catch (error) {
    errorMessage = `Unable to publish help information: ${error.message}`
    errorSuggestion = `Check comment message for any not allowed characters.`
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Retrieve base issue information.
 * Required permissions on default GITHUB_TOKEN: 'pull requests' and 'issues' (read)
 *
 * @param {string} owner Owner of repository where target issue has been created.
 * @param {string} repo Name or repository which contains target issue.
 * @param {number} issue GitHub issue / pull request number.
 * @param {boolean} fetchIfPullRequest Whether information should be re-fetched if data represent pull request.
 *
 * @return {Promise<OperationOutcome & (GitHubIssue|GitHubPullRequest)>} Asynchronous issue information fetch results.
 */
export const getIssueInformation = async (
  owner: string,
  repo: string,
  issue: number,
  fetchIfPullRequest: boolean = false
): Promise<OperationOutcome & (GitHubIssue | GitHubPullRequest)> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const token: string = action.github.ghToken || action.github.token
  let errorMessage, errorSuggestion: string | undefined
  let head: GitHubPullRequest['head'] | undefined
  let base: GitHubPullRequest['base'] | undefined
  let type: 'issue' | 'pull-request' = 'issue'
  let state: GitHubIssue['state'] | undefined
  const octokit = github.getOctokit(token)
  let isPullRequest: boolean | undefined
  let title, creator, body: string | undefined

  try {
    let response: { data: Record<string, any> } = await octokit.request(
      'GET /repos/{owner}/{repo}/issues/{issue_number}',
      {owner, repo, issue_number: issue}
    )

    title = response.data['title']

    if (fetchIfPullRequest && response.data['pull_request']) {
      response = await octokit.request(
        'GET /repos/{owner}/{repo}/pulls/{pull_number}',
        {owner, repo, pull_number: issue}
      )
      isPullRequest = true
      type = 'pull-request'
    } else isPullRequest = false

    if (response.data['user'] && response.data['user'].login) creator = response.data['user'].login
    else errorMessage = 'Issue author information is missing.'

    if (response.data['state']) state = response.data['state'] as GitHubIssue['state']
    else errorMessage = 'Issue state information is missing.'

    if (response.data['body']) body = response.data['body']
    else errorMessage = 'Issue body information is missing.'

    if (isPullRequest && fetchIfPullRequest) {
      if (response.data['head'] && response.data['head'].repo)
        head = {
          ref: response.data['head'].ref,
          repo: response.data['head'].repo.name,
          owner: response.data['base'].repo.owner.login,
          fork: response.data['base'].repo.fork,
          cloneUrl: cloneUrl(token, response.data['head'].repo.clone_url)
        }
      else errorMessage = 'Pull request head information is missing.'

      if (response.data['base'])
        base = {
          ref: response.data['base'].ref,
          repo: response.data['base'].repo.name,
          owner: response.data['base'].repo.owner.login,
          cloneUrl: cloneUrl(token, response.data['base'].repo.clone_url)
        }
      else errorMessage = 'Pull request base information is missing.'
    }

    if (errorMessage) errorSuggestion = 'Ensure that requested endpoint provide this field.'
  } catch (error) {
    errorMessage = `Unable to fetch issue information: ${error.message}`
    errorSuggestion = 'Check issue number and for private repository whether specified \'token\' has required permissions.'
  }

  return {
    type,
    number: issue,
    title,
    body: body ?? '',
    state: state ?? 'closed',
    creator: creator ?? '',
    isPullRequest,
    head: head ?? {ref: '', repo: '', owner: '', fork: false, cloneUrl: ''},
    base: base ?? {ref: '', repo: '', owner: '', cloneUrl: ''},
    successful: !errorMessage,
    errorMessage,
    errorSuggestion
  }
}

/**
 * Retrieve base information for list of issues.
 * Required permissions on default GITHUB_TOKEN: 'pull requests' and 'issues' (read)
 *
 * @param {string} owner Owner of repository where target issue has been created.
 * @param {string} repo Name or repository which contains target issue.
 * @param {number[]} issues GitHub issues / pull requests numbers.
 *
 * @return {Promise<GitHubIssues>} Asynchronous issues information fetch results.
 */
export const getIssuesInformation = async (owner: string, repo: string, issues: number[]): Promise<GitHubIssues> => {
  let fetchedIssues: (GitHubIssue|GitHubPullRequest)[] = []
  let errorMessage, errorSuggestion: string | undefined

  for (let issue of issues) {
    const issueInformation = await getIssueInformation(owner, repo, issue)

    if (!issueInformation.successful) {
      errorMessage = issueInformation.errorMessage
      errorSuggestion = issueInformation.errorSuggestion
      break
    } else fetchedIssues.push(issueInformation)

    // Wait a bit to not be throttled.
    await new Promise(resolve => setTimeout(resolve, 1000))
  }

  return {issues: !errorMessage ? fetchedIssues : undefined, successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Retrieve list of existing tags for specified repository.
 * Required permissions on default GITHUB_TOKEN: 'metadata' (read)
 *
 * @param {string} owner Owner of repository for which audit will be done.
 * @param {string} repo Name of repository who's tags should be retrieved.
 * @param {number} limit How many last tags should be retrieved.
 *
 * @return {Promise<GitHubRepositoryTags>} Asynchronous results of tags audition.
 */
export const getRepositoryTags = async (owner: string, repo: string, limit: number = 100): Promise<GitHubRepositoryTags> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const token: string = action.github.ghToken || action.github.token
  let errorMessage, errorSuggestion: string | undefined
  const tagsPerPage = Math.min(100, limit)
  let tags: GitHubRepositoryTags['tags'] = []
  const octokit = github.getOctokit(token)

  while (tags.length < limit && !errorMessage) {
    try {
      const response = await octokit.request('GET /repos/{owner}/{repo}/tags',
        {owner, repo, per_page: Math.min(100, limit - tags.length)}
      )

      tags.push(...response.data)

      if (response.data.length < tagsPerPage) break
    } catch (error) {
      errorMessage = `Unable to get ${repo} tags: ${error}`
      errorSuggestion = 'Ensure that provided token has permissions to access GitHub repository tags.'
    }
  }

  return {tags, successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Retrieve information about configured GitHub Pages.
 * Required permissions on extended token: 'pages' (read)
 *
 * @param {string} owner Owner of repository for which GitHub Pages information should be retrieved.
 * @param {string} repo Name or repository which may have configured GitHub Pages.
 *
 * @return {Promise<OperationOutcome>} Asynchronous comment publish results.
 */
export const getPagesInformation = async (owner: string, repo: string): Promise<GitHubPages> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  let pagesData: {branch: string; path: string} | undefined
  const octokit = github.getOctokit(action.github.token!)
  let errorMessage, errorSuggestion: string | undefined

  try {
    const response = await octokit.request('GET /repos/{owner}/{repo}/pages', {owner, repo})
    pagesData = response.data.source
  } catch (error) {
    if (error.status !== 404) {
      errorMessage = `Unable to get GitHub Pages information: ${error}`
      errorSuggestion = 'Ensure that provided token has permissions to access GitHub Pages information.'
    }
  }

  return {
    ...(pagesData ? pagesData : {}),
    configured: pagesData !== undefined,
    successful: !errorMessage,
    errorMessage,
    errorSuggestion
  }
}

/**
 * Setup GitHub Pages site.
 * Required permissions on extended token: 'pages' (read)
 *
 * @param {string} owner Owner of repository for which GitHub Pages should be setup.
 * @param {string} repo Name or repository where GitHub Pages will be stored.
 * @param {string} branch Name of branch which will be source for GitHub Pages site.
 * @param {'/'|'/docs'} path Relative path to the folder which has content for GitHub Pages site.
 *
 * @return {Promise<GitHubPages>} Asynchronous results for GitHub Pages setup.
 */
export const setPagesInformation = async (
  owner: string,
  repo: string,
  branch: string,
  path: '/' | '/docs'
): Promise<GitHubPages> => {
  const octokit = github.getOctokit(action.github.token!)
  let errorMessage, errorSuggestion: string | undefined

  try {
    await octokit.request('POST /repos/{owner}/{repo}/pages',
      {owner, repo, source: {branch, path}, mediaType: {previews: ['switcheroo']}}
    )
  } catch (error) {
    errorMessage = `Unable to setup GitHub Pages: ${error}`
    errorSuggestion = 'Ensure that provided token has permissions to change GitHub Pages information.'
  }

  return {
    configured: !!errorMessage,
    branch: !errorMessage ? branch : undefined,
    path: !errorMessage ? path : undefined,
    successful: !errorMessage,
    errorMessage,
    errorSuggestion
  }
}

/**
 * Retrieve list of previously created labels for specified repository.
 * Required permissions on default GITHUB_TOKEN: 'labels' (read)
 *
 * @param {string} owner Owner of repository for which audit will be done.
 * @param {string} repo Name of repository who's labels should be retrieved.
 *
 * @return {Promise<GitHubRepositoryLabels>} Asynchronous results of labels audition.
 */
export const getRepositoryLabels = async (owner: string, repo: string): Promise<GitHubRepositoryLabels> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const token: string = action.github.ghToken || action.github.token
  let errorMessage, errorSuggestion: string | undefined
  let labels: GitHubRepositoryLabels['labels'] = []
  const octokit = github.getOctokit(token)

  try {
    const response = await octokit.request('GET /repos/{owner}/{repo}/labels', {owner, repo})

    for (let label of response.data) {
      labels.push({name: label.name, description: label.description, color: label.color})
    }
  } catch (error) {
    errorMessage = `Unable to get ${repo} labels: ${error}`
    errorSuggestion = 'Ensure that provided token has permissions to access GitHub repository labels.'
  }

  return {labels, successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Prepare repository labels replacement plan.
 *
 * @param {RepositoryLabelsSet} expectedLabelsSet Set of expected labels.
 * @param {GitHubRepositoryLabel[]} existingLabels Labels which already exists for repository.
 *
 * @return {{add: GitHubRepositoryLabel[], remove: GitHubRepositoryLabel[]}} Repository labels replacement plan.
 */
export const repositoryLabelsSetPlan = (
  expectedLabelsSet: RepositoryLabelsSet,
  existingLabels: GitHubRepositoryLabel[]
): {
  add: GitHubRepositoryLabel[]
  remove: GitHubRepositoryLabel[]
} => {
  const expectedLabels: GitHubRepositoryLabel[] = Array.prototype.concat.apply(
    [],
    Object.keys(expectedLabelsSet).map(group =>
      expectedLabelsSet[group].map(label => {
        return {...label, ...{name: `${group}: ${label.name}`}}
      })
    )
  )
  const expectedLabelNames = expectedLabels.map(label => label.name)
  const existingLabelNames = existingLabels.map(label => label.name)

  return {
    add: expectedLabels.filter(label => existingLabelNames.indexOf(label.name) < 0),
    remove: existingLabels.filter(label => expectedLabelNames.indexOf(label.name) < 0)
  }
}

/**
 * Set repository labels to expected list.
 * Required permissions on default GITHUB_TOKEN: 'labels' (write)
 *
 * @param {string} owner Owner of repository on which labels manipulation will be done.
 * @param {string} repo Name of repository for which labels should be replaced.
 * @param {GitHubRepositoryLabel[]} labelsToAdd List of labels, which should be added.
 * @param {GitHubRepositoryLabel[]} labelsToRemove List of labels, which should be removed.
 *
 * @return {Promise<OperationOutcome>} Asynchronous labels replacement result.
 */
export const setRepositoryLabels = async (
  owner: string,
  repo: string,
  labelsToAdd: GitHubRepositoryLabel[] = [],
  labelsToRemove: GitHubRepositoryLabel[] = []
): Promise<OperationOutcome> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const token: string = action.github.ghToken || action.github.token
  let errorMessage, errorSuggestion: string | undefined
  // const octokit = github.getOctokit(action.github.token!)
  const octokit = github.getOctokit(token)

  for (let label of labelsToAdd) {
    try {
      await octokit.request('POST /repos/{owner}/{repo}/labels',
        {owner, repo, name: label.name, color: label.color, description: label.description ? label.description : undefined}
      )

      // Wait a bit to not be throttled.
      await new Promise(resolve => setTimeout(resolve, 500))
    } catch (error) {
      errorMessage = `Unable to create ${label.name} label: ${error}`
      errorSuggestion = 'Ensure that provided token has permissions to manage GitHub repository labels.'
    }

    if (errorMessage) break
  }

  if (!errorMessage) {
    for (let label of labelsToRemove) {
      try {
        await octokit.request('DELETE /repos/{owner}/{repo}/labels/{name}',
          {owner, repo, name: label.name}
        )

        // Wait a bit to not be throttled.
        await new Promise(resolve => setTimeout(resolve, 500))
      } catch (error) {
        errorMessage = `Unable to delete ${label.name} label: ${error}`
        errorSuggestion = 'Ensure that provided token has permissions to manage GitHub repository labels.'
      }
    }
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Update issue labels set by adding and removing specific set of labels.
 * Required permissions on default GITHUB_TOKEN: 'labels' (write)
 *
 * @param {string} owner Owner of repository on which labels manipulation will be done.
 * @param {string} repo Name of repository for which labels should be replaced.
 * @param {number} number Issue / PR number on which labels should be updated.
 * @param {string[]} labelsToAdd List of labels, which should be added to the issue / PR.
 * @param {string[]} labelsToRemove List of labels, which should be removed from issue / PR.
 *
 * @return {Promise<OperationOutcome>} Asynchronous issue labels manipulation results.
 */
export const updateIssueLabels = async (
  owner: string,
  repo: string,
  number: number,
  labelsToAdd: string[],
  labelsToRemove: string[]
): Promise<OperationOutcome> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const token: string = action.github.ghToken || action.github.token
  let errorMessage, errorSuggestion: string | undefined
  // const octokit = github.getOctokit(action.github.token!)
  const octokit = github.getOctokit(token)
  let addedLabels: string[] = []

  try {
    const issueLabels = await octokit.request(
      'GET /repos/{owner}/{repo}/issues/{issue_number}/labels',
      {owner, repo, issue_number: number}
    )

    addedLabels = issueLabels.data.map(label => label.name)
  } catch (error) {
    errorMessage = `Unable to get list if labels for ${number} issue: ${error}`
    errorSuggestion = 'Ensure that provided token has permissions to access issue / PR labels.'
  }

  labelsToAdd = labelsToAdd.filter(label => !addedLabels.includes(label))

  let issueLabels = addedLabels.filter(label => !labelsToRemove.includes(label))
  issueLabels.push(...labelsToAdd)

  try {
    await octokit.request(
      'PUT /repos/{owner}/{repo}/issues/{issue_number}/labels',
      // @ts-ignore Types confused linter.
      {owner, repo, issue_number: number, labels: issueLabels}
    )
  } catch (error) {
    errorMessage = `Unable to set new labels for ${number} issue: ${error}`
    errorSuggestion = 'Ensure that provided token has permissions to manage issue / PR labels.'
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Iterate through change log and close any addressed issues with feedback to the author.
 * Required permissions on default GITHUB_TOKEN: 'issues' (write)
 *
 * @param {string} owner Owner of repository for which release prepared.
 * @param {string} repo Name or repository with upcoming release for which changelog has been generated.
 * @param {Changelog} changelog Previously generated changelog for current release.
 *
 * @return {Promise<OperationOutcome>} Asynchronous result of issues close.
 */
export const closeIssuesFromChangeLog = async (
  owner: string,
  repo: string,
  changelog: Changelog
): Promise<OperationOutcome> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const token: string = action.github.ghToken || action.github.token
  const octokit = github.getOctokit(token)

  const labelsPolicyPath = path.join(
    action.rootWorkingDirectory,
    GITHUB_ACTIONS_PATH,
    'resources',
    'github',
    'labels-policy.json'
  )
  const labelsPolicy: RepositoryLabelsReleaseChangePolicy = JSON.parse(
    fs.readFileSync(labelsPolicyPath).toString('utf8')
  )

  for (let change of changelog.entries) {
    if (change.addressedIssues && change.addressedIssues.length) {
      for (let issue of change.addressedIssues) {
        log.info(
          `Notifying ${styles.bold.open}@${issue.author}${
            styles.bold.close
          } that ${issue.isPullRequest ? 'PR' : 'issue'} ${styles.bold.open}#${
            issue.issue
          }${styles.bold.close}`
        )
        // Publish acknowledgment comment to issue / PR.
        let comment = `@${issue.author} this issue is addressed in [${changelog.version}](https://github.com/${owner}/${repo}/releases/tag/${changelog.version})`
        if (issue.isPullRequest)
          comment = `@${issue.author} your suggested changes are addressed in [${changelog.version}](https://github.com/${owner}/${repo}/releases/tag/${changelog.version})`

        await publishComment(owner, repo, issue.issue, comment)

        // Wait a bit to not be throttled.
        await new Promise(resolve => setTimeout(resolve, 500))

        // Change labels set.
        const issueLabelChanges = issue.isPullRequest ? labelsPolicy['pull-request'] : labelsPolicy.issue
        await updateIssueLabels(owner, repo, issue.issue, issueLabelChanges.add, issueLabelChanges.remove)

        // Wait a bit to not be throttled.
        await new Promise(resolve => setTimeout(resolve, 500))

        // Close issue if required.
        const issueInformation = await getIssueInformation(owner, repo, issue.issue)

        // Closing issue if required.
        if (issueInformation.successful && issueInformation.state !== 'closed') {
          log.info(`Closing ${issue.isPullRequest ? 'PR' : 'issue'} ${styles.bold.open}#${issue.issue}${styles.bold.close}`)

          try {
            await octokit.request(
              'PATCH /repos/{owner}/{repo}/issues/{issue_number}',
              {owner, repo, issue_number: issue.issue, state: 'closed'}
            )
          } catch (error) {
            // Do nothing, because it is not main feature.
          }

          // Wait a bit to not be throttled.
          await new Promise(resolve => setTimeout(resolve, 500))
        }
      }
    }
  }

  return {successful: true}
}

/**
 * Create new GitHub release ready for artifacts upload.
 * Required permissions on default GITHUB_TOKEN: 'releases' (write)
 *
 * @param {string} owner Owner of repository for which release should be created.
 * @param {string} repo Name or repository where new GitHub Release should be available.
 * @param {string} tag Name of tag which has been created for changed code.
 * @param {string} product Name of product for which release will be created.
 * @param {Changelog} changelog Previously generated changelog for current release.
 * @param {boolean} draft Whether creating draft PR or not.
 *
 * @return {Promise<GitHubRelease>} Asynchronous GitHub Release create result.
 */
export const createRelease = async (
  owner: string,
  repo: string,
  tag: string,
  product: string,
  changelog: string,
  draft: boolean = true
): Promise<GitHubRelease> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const token: string = action.github.ghToken || action.github.token
  let releaseName = product.length ? `${product} ${tag}` : tag
  let errorMessage, errorSuggestion: string | undefined
  const octokit = github.getOctokit(token)
  let uploadUrl: string | undefined
  let id: number | undefined

  try {
    log.info(`Check whether ${styles.bold.open}${releaseName}${styles.bold.close} release already exists or not.`)
    const releases = await octokit.request('GET /repos/{owner}/{repo}/releases', {owner, repo, per_page: 100})
    const currentRelease = releases.data.filter(release => release.name === releaseName)
    if (currentRelease.length) id = currentRelease[0].id
  } catch (error) {
    errorMessage = `Unable to get releases list: ${error}`
    errorSuggestion = 'Ensure that provided token has permissions to access GitHub releases.'
  }

  if (id) {
    log.info(`Deleting existing ${styles.bold.open}${releaseName}${styles.bold.close} release.`)
    try {
      await octokit.request('DELETE /repos/{owner}/{repo}/releases/{release_id}', {owner, repo, release_id: id})
    } catch (error) {
      errorMessage = `Unable to get releases list: ${error}`
      errorSuggestion = 'Ensure that provided token has permissions to access GitHub releases.'
    }
  }

  if (!errorMessage) {
    log.info(`Creating ${styles.bold.open}${releaseName}${styles.bold.close} release.`)
    try {
      const response = await octokit.request('POST /repos/{owner}/{repo}/releases',
        {owner, repo, tag_name: tag, body: changelog, name: releaseName, draft}
      )
      uploadUrl = response.data.upload_url.replace(/{.*}/m, '')
      id = response.data.id
    } catch (error) {
      errorMessage = `Unable to set created ${draft ? 'draft' : 'regular'} release: ${error}`
      errorSuggestion = 'Ensure that provided token has permissions to create GitHub releases.'
    }
  }

  return {uploadUrl, id, successful: !errorMessage, errorMessage, errorSuggestion}
}