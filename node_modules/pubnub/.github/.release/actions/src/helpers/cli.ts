import {ExecOptions, exec} from '@actions/exec'
import path from 'path'
import fs from 'fs'
import {REPOSITORY_ACTIONS_PATH} from '../constants'
import {OperationOutcome} from './types'
import {action} from './actions'

/** Type with CLI execution configuration options. */
export type CLIExecParameters = {
  /** Name of CLI which should be called. */
  cli: string

  /** List of arguments, which should be passed to CLI. */
  commandOrFlags?: string[]

  /** Action's `exec` module configuration options. */
  execOptions?: ExecOptions
}

/** Type for CLI execution results representation. */
export type CLIExecResult = {
  /** CLI execution exit code. */
  code: number

  /** Content of `stdout` stream. */
  stdout: string

  /** Content of `stderr` stream. */
  stderr: string
}

/** Type for CLI execution results representation. */
export type CLICheckResult = {
  /** Whether specified CLI available or not. */
  available: boolean

  /** Output of command, which has been used to check CLI availability. */
  output: string
}

/**
 * CLI execution helper function.
 *
 * @param {CLIExecParameters} options Options with information about CLI and it's
 * arguments.
 *
 * @return {Promise<CLIExecResult>} Asynchronously retrieved command output.
 */
export const cliExec = async (options: CLIExecParameters): Promise<CLIExecResult> => {
  const result: CLIExecResult = {code: 1, stdout: '', stderr: ''}
  options.execOptions ??= {silent: true, ignoreReturnCode: true}

  // Adding / override listeners to track CLI execution output.
  options.execOptions.listeners = {
    stdout: data => (result.stdout += data.toString()),
    stderr: data => (result.stderr += data.toString())
  }

  if (options.execOptions.silent === undefined) options.execOptions.silent = true
  if (options.execOptions.ignoreReturnCode === undefined) options.execOptions.ignoreReturnCode = true

  /**
   * Changing working directory in which `cli` should be called.
   * Added to cover monorepo support.
   */
  if (!options.execOptions.cwd) options.execOptions.cwd = action.productWorkingDirectory

  try {
    result.code = await exec(options.cli, options.commandOrFlags, options.execOptions)
  } catch (error) {
    result.stderr = error.message
  }

  return result
}

/**
 * CLI presence check helper function.
 *
 * @param {CLIExecParameters} options Options with information about CLI and it's
 * arguments.
 *
 * @return {Promise<CLICheckResult>} Asynchronously retrieved results of CLI presence
 * check.
 */
export const cliCheck = async (options: CLIExecParameters): Promise<CLICheckResult> => {
  const execResult = await cliExec(options)
  return {available: execResult.code == 0, output: execResult.stdout || execResult.stderr}
}

/**
 * Extract CLI version from `version` command / option output.
 *
 * @param {string} output Output of command which expected to provide CLI version.
 * @param {RegExp?} regexp Custom regular expression (default: ([0-9]+(\.[0-9]){2,})).
 * @param {number?} matchIndex Index fom match array which should be used to get data.
 *
 * @return {string | undefined} Version number if present or `undefined` in other case.
 */
export const cliVersion = (output: string, regexp?: RegExp, matchIndex?: number): string | undefined => {
  const matchResult = output.match(regexp ?? /([0-9]+(\.[0-9]+){2,})/m)
  matchIndex ??= 1

  return matchResult && matchResult.length > matchIndex ? matchResult[matchIndex] : undefined
}

/**
 * Exec scripts stored in repository's `.github/workflows/release` folder.
 * `name` will be prefix for `.sh` and `.js` in attempt to find scripts which can be executed.
 *
 * @param {string} name Name of script which should be executed.
 * @param {string} workDir Full path to repository root directory. Can be different on changelog generation.
 * @param {boolean} repo Whether user scripts stored within current repository or by work dir.
 *
 * @return {Promise<OperationOutcome>} Asynchronous scripts execution results.
 */
export const execUserScript = async (name: string, workDir?: string, repo: boolean = true): Promise<OperationOutcome> => {
  workDir ??= action.rootWorkingDirectory
  const cwd = repo ? action.productWorkingDirectory : workDir
  const scriptsPath = path.join(workDir, REPOSITORY_ACTIONS_PATH)
  const bashScriptPath = path.join(scriptsPath, `${name}.sh`)
  const nodeScriptPath = path.join(scriptsPath, `${name}.js`)
  let errorMessage, errorSuggestion: string | undefined
  let execResult: CLIExecResult | undefined
  let scriptType = 'bash'

  // Try to run bash script.
  if (fs.existsSync(bashScriptPath)) {
    fs.chmodSync(bashScriptPath, 0o755)

    execResult = await cliExec({
      cli: process.env['SHELL'] || 'bash',
      commandOrFlags: [bashScriptPath, cwd],
      execOptions: {cwd}
    })
  }

  // Try to run NodeJS script.
  if ((!execResult || execResult.code === 0) && fs.existsSync(nodeScriptPath)) {
    fs.chmodSync(nodeScriptPath, 0o755)
    scriptType = 'nodejs'

    execResult = await cliExec({
      cli: 'node',
      commandOrFlags: [nodeScriptPath, cwd],
      execOptions: {cwd}
    })
  }

  if (execResult && execResult.code !== 0) {
    errorMessage = `Unable to call ${name} ${scriptType} script: ${execResult.stderr || execResult.stdout}`
    errorSuggestion = 'Ensure that script has executable permissions and doesn\'t contains logical / syntax errors.'
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}
