import {ExecOptions} from '@actions/exec'
import {cliExec, CLIExecResult} from './cli'
import {OperationOutcome} from './types'
import {action} from './actions'

/** Branch check results representation. */
export type GitBranchCheckResult = OperationOutcome & {
  /** Whether specified branch exists in target repository or not. */
  exists: boolean
}

/**
 * Complete git configuration so it will be possible to use token for repository pull / push.
 *
 * @param {string} name Name of user who's name will be shown as changes committer.
 * @param {string} email Email address of user who's name will be shown as changes committer.
 */
export const setupGit = async (name: string, email: string): Promise<OperationOutcome> => {
  // Make changes only when running command on CI.
  if (!process.env['CI']) return {successful: true}

  await cliExec({cli: 'git', commandOrFlags: ['config', '--global', 'user.email', email]})
  await cliExec({cli: 'git', commandOrFlags: ['config', '--global', 'user.name', name]})

  // Unset previous authentication
  await cliExec({cli: 'git', commandOrFlags: ['config', '--local', '--unset-all', 'http.https://github.com/.extraheader']})

  // Adding replacing remote with token based clone path (so it will be possible to push changes if required.
  await cliExec({cli: 'git', commandOrFlags: ['remote', 'rm', 'origin']})

  const execResult = await cliExec({cli: 'git', commandOrFlags: ['remote', 'add', 'origin', action.repository.cloneUrl]})

  return {
    successful: execResult.code === 0,
    errorMessage: execResult.code !== 0 ? `Unable replace 'origin' remote: ${execResult.stderr || execResult.stdout}` : undefined,
    errorSuggestion: execResult.code !== 0 ? 'Review git remote add call result.' : undefined
  }
}

/**
 * Clone specified location or current directory.
 *
 * @param {string} url Git repository clone url.
 * @param {string} path Full-path to location where local copy should be cloned.
 * @param {string} branch Name of single branch, which can be cloned and point HEAD to it.
 *
 * @return {Promise<OperationOutcome>} Asynchronous git clone call result.
 */
export const gitClone = async (url: string, path?: string, branch?: string): Promise<OperationOutcome> => {
  let errorMessage, errorSuggestion: string | undefined
  let commandOrFlags = ['clone']

  if (branch) commandOrFlags.push(...['-b', branch, '--single-branch'])
  commandOrFlags.push(url)
  if (path) commandOrFlags.push(path)

  const execResult = await cliExec({cli: 'git', commandOrFlags})

  if (execResult.code !== 0) {
    errorMessage = `Unable to clone ${url}: ${execResult.stderr || execResult.stdout}`
    errorSuggestion = 'Check whether provided user credentials is enough to access target repository.'
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Check whether branch exists in specified repository or not.
 *
 * @param {string} url HTTP based remote repository URL.
 * @param {string} branch Name of branch which should be checked.
 *
 * @return {Promise<GitBranchCheckResult>} Asynchronous results of branch existence check.
 */
export const gitCheckBranchExists = async (url: string, branch: string): Promise<GitBranchCheckResult> => {
  let errorMessage, errorSuggestion: string | undefined
  let branchExists = false

  const execResult = await cliExec({cli: 'git', commandOrFlags: ['ls-remote', '--heads', url, `refs/heads/${branch}`]})

  if (execResult.code !== 0) {
    errorMessage = `Unable to create new branch: ${execResult.stderr || execResult.stdout}.`
    errorSuggestion = 'Check \'git checkout\' command error output.'
  } else branchExists = execResult.stdout.length > 0

  return {exists: branchExists, successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Checkout / create branch.
 *
 * @param {string} branch Name of branch which should be created.
 * @param {{orphan:boolean,reset:boolean}} options Branch checkout configuration options.
 * @param {boolean} exists Previous branch existence results.
 * @param {string} path Full-path to directory within which call should be done.
 *
 * @return {Promise<OperationOutcome>} Asynchronous git checkout call result.
 */
export const gitCheckoutBranch = async (
  branch: string,
  options: { orphan: boolean; reset: boolean; depth?: number } = {orphan: false, reset: false},
  exists: boolean | undefined = undefined,
  path?: string
): Promise<OperationOutcome> => {
  let errorMessage, errorSuggestion: string | undefined
  let checkResult: GitBranchCheckResult | undefined
  let execResult: CLIExecResult | undefined
  let execOptions: ExecOptions = {}

  if (path) execOptions.cwd = path
  if (exists === undefined) checkResult = await gitCheckBranchExists(action.repository.cloneUrl, branch)

  if (!checkResult || checkResult.successful) {
    if ((checkResult && checkResult.exists) || exists) {
      let commandOrFlags = ['fetch', '--no-recurse-submodules']
      if (options.depth) commandOrFlags.push(`--depth=${options.depth}`)
      commandOrFlags.push(...['origin', branch])

      execResult = await cliExec({cli: 'git', commandOrFlags, execOptions})
    }

    if (!execResult || execResult.code === 0) {
      let commandOrFlags = ['checkout', options.orphan ? '--orphan' : '-B', branch]
      if ((checkResult && checkResult.exists) || exists) commandOrFlags.push(`origin/${branch}`)

      execResult = await cliExec({cli: 'git', commandOrFlags, execOptions})
    }

    if (execResult.code === 0 && !exists && options.reset)
      execResult = await cliExec({cli: 'git', commandOrFlags: ['reset', '--hard'], execOptions})

    if (execResult.code === 0 && !exists && options.reset && options.orphan) {
      execResult = await cliExec({
        cli: 'git',
        commandOrFlags: ['commit', '--no-verify', '--allow-empty', '-m', `"Initial ${branch} commit."`],
        execOptions
      })
    }

    if (execResult.code !== 0) {
      errorMessage = `Unable to checkout branch: ${execResult.stderr || execResult.stdout}.`
      errorSuggestion = 'Check token owner permissions to access repository.'
    }
  } else {
    errorMessage = checkResult.errorMessage
    errorSuggestion = checkResult.errorSuggestion
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Add new files to git.
 *
 * @param {string} path Full-path to directory within which call should be done.
 *
 * @return {Promise<OperationOutcome>} Asynchronous `git add` call result.
 */
export const gitAdd = async (path?: string): Promise<OperationOutcome> => {
  let errorMessage, errorSuggestion: string | undefined
  let execOptions: ExecOptions = {}

  if (path) execOptions.cwd = path

  const execResult = await cliExec({cli: 'git', commandOrFlags: ['add', '--all', '.'], execOptions})

  if (execResult.code !== 0) {
    errorMessage = `Unable to add changed / modified files: ${execResult.stderr || execResult.stdout}.`
    errorSuggestion = 'Check \'git add\' command error output.'
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Add new files to git.
 *
 * @param {string} message Commit message to explain changes.
 * @param {string} path Full-path to directory within which call should be done.
 *
 * @return {Promise<OperationOutcome>} Asynchronous `git commit` call result.
 */
export const gitCommit = async (message: string, path?: string): Promise<OperationOutcome> => {
  let execOptions: ExecOptions = {}

  if (path) execOptions.cwd = path

  await cliExec({cli: 'git', commandOrFlags: ['commit', '-a', '-m', message], execOptions})

  return {successful: true}
}

/**
 * Create tag for specified version.
 *
 * @param {string} version Upcoming release version.
 * @param {string} path Full-path to directory within which call should be done.
 *
 * @return {Promise<OperationOutcome>} Asynchronous `git tag` call result.
 */
export const gitTag = async (version: string, path?: string): Promise<OperationOutcome> => {
  let errorMessage, errorSuggestion: string | undefined
  let execOptions: ExecOptions = {}

  if (path) execOptions.cwd = path

  const execResult = await cliExec({cli: 'git', commandOrFlags: ['tag', version], execOptions})

  if (execResult.code !== 0) {
    errorMessage = `Unable to create ${version} tag: ${execResult.stderr || execResult.stdout}.`
    errorSuggestion = 'Check \'git tag\' command error output.'
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Add new files to git.
 *
 * @param {string} path Full-path to directory within which call should be done.
 * @param {boolean} force Whether force push should be done using current branch.
 * @param {string} sourceBranch Name of source branch which contain changes.
 * @param {string} targetBranch Name of remote branch into which changes should be pushed.
 *
 * @return {Promise<OperationOutcome>} Asynchronous `git push` call result.
 */
export const gitPush = async (
  path?: string,
  sourceBranch?: string,
  targetBranch?: string,
  force: boolean = false
): Promise<OperationOutcome> => {
  let errorMessage, errorSuggestion: string | undefined
  let execOptions: ExecOptions = {}
  let commandOrFlags = ['push']

  if (force) commandOrFlags.push('--force')

  commandOrFlags.push(action.repository.cloneUrl)

  if (targetBranch) commandOrFlags.push(`${sourceBranch}:${targetBranch}`)
  else if (sourceBranch) commandOrFlags.push(sourceBranch)

  if (path) execOptions.cwd = path

  const execResult = await cliExec({cli: 'git', commandOrFlags, execOptions})

  if (execResult.code !== 0) {
    errorMessage = `Unable to push changes: ${execResult.stderr || execResult.stdout}.`
    errorSuggestion = 'Check credentials and that \'token\' owner has permissions to push changes.'
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}
