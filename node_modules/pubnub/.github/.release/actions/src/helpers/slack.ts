import styles from 'ansi-styles'
import fetch from 'node-fetch'
import path from 'path'
import fs from 'fs'
import {projectReleaseCompletionNotificationChannel, projectReleaseStartNotificationChannel, repositoryProductName} from './jira'
import {JIRAProjectRelease, OperationOutcome, ReleaseProcessOutcome} from './types'
import {action, checkReleaseProcessStepDone} from './actions'
import {GITHUB_ACTIONS_PATH} from '../constants'
import {capitalizedString} from './string'
import * as log from './log'


/** Pre-load webhooks information. */
const webhooksPath = path.join(action.rootWorkingDirectory, GITHUB_ACTIONS_PATH, 'resources', 'slack', 'incoming-webhooks.json')
const webhooks: { channels: Record<string, string> } = JSON.parse(fs.readFileSync(webhooksPath).toString('utf8'))

/**
 * Send notification about product release start (if possible for current repository).
 *
 * @param {ReleaseProcessOutcome} release Ongoing release process information.
 * @param {JIRAProjectRelease} releaseVersion JIRA release ticket for currently released product.
 *
 * @return {Promise<OperationOutcome>} Results of message publish to Slack channel.
 */
export const notifySlackChannelReleaseStart = async (
  release: ReleaseProcessOutcome,
  releaseVersion?: JIRAProjectRelease
): Promise<OperationOutcome> => await sendReleaseNotificationToChannel(false, release, releaseVersion)

/**
 * Send notification about product release completion (if possible for current repository).
 *
 * @param {ReleaseProcessOutcome} release Ongoing release process information.
 * @param {JIRAProjectRelease} releaseVersion JIRA release ticket for currently released product.
 *
 * @return {Promise<OperationOutcome>} Results of message publish to Slack channel.
 */
export const notifySlackChannelReleaseCompleted = async (
  release: ReleaseProcessOutcome,
  releaseVersion?: JIRAProjectRelease
): Promise<OperationOutcome> => await sendReleaseNotificationToChannel(true, release, releaseVersion)

/**
 * Release notification messages composition and publish.
 *
 * @param {boolean} completed Whether blocks for release completion expected to be generated.
 * @param {ReleaseProcessOutcome} release Ongoing release process information.
 * @param {JIRAProjectRelease} releaseVersion JIRA release ticket for currently released product.
 *
 * @return {Promise<OperationOutcome>} Results of message publish to Slack channel.
 */
const sendReleaseNotificationToChannel = async (
  completed: boolean,
  release: ReleaseProcessOutcome,
  releaseVersion?: JIRAProjectRelease
): Promise<OperationOutcome> => {
  const slackChannel = !completed ? projectReleaseStartNotificationChannel() : projectReleaseCompletionNotificationChannel()
  const webhook: string | undefined = slackChannel ? webhooks.channels[slackChannel] : undefined
  let outcome: OperationOutcome = {successful: true}
  let errorSuggestion: string | undefined
  let errorMessage: string | undefined

  // Missing channel for project shouldn't be reason to fail build.
  if (!slackChannel) {
    log.warning(`There is no Slack channel to notify about release ${ 
      !completed ? 'start' : 'completion' } on ${styles.bold.open}${
      action.repository.repo}${styles.bold.close} repository.`)
    return outcome
  }

  // Missing channel for project shouldn't be reason to fail build.
  if (!webhook) {
    log.warning(`There is no Slack webhook to be used for ${styles.bold.open}${
      action.repository.repo}${styles.bold.close} repository.`)
    return outcome
  }

  // Potentially release happens on repository, which not fully configured on JIRA configuration file side.
  const productName = releasedProductName(release)
  if (!productName) {
    log.warning('Unable detect released product name. Skip notification to Slack.')
    return outcome
  }

  // Retrieve blocks for notification message.
  const blocks = releaseNotificationBlocks(completed, release, releaseVersion)
  if (!blocks) {
    log.warning('Unable prepare notification message. Skip notification to Slack.')
    return outcome
  }

  try {
    const response = await fetch(webhook, {
      method: 'post',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({blocks})
    })

    if (!response.ok) {
      errorMessage = `Unable to post message: ${await response.text()}`
      errorSuggestion = 'Check composed payload and make sure that correct webhook has been used.'
    }

  } catch (error) {
    errorMessage = `Unable to post message: ${error}`
    errorSuggestion = 'Make sure that correct webhook has been used.'
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Decide on name of product which has been released.
 *
 * @param {ReleaseProcessOutcome} release Ongoing release process information.
 *
 * @return {string | undefined} Currently released product name (monorepo) or decided basing on repository name.
 */
const releasedProductName = (release: ReleaseProcessOutcome): string | undefined =>
  release.product && release.product.name !== action.repository.repo ? release.product.name : repositoryProductName()

/**
 * Generate set of blocks which represent payload of Slack message.
 *
 * @param {boolean} completed Whether blocks for release completion expected to be generated.
 * @param {ReleaseProcessOutcome} release Ongoing release process information.
 * @param {JIRAProjectRelease} releaseVersion JIRA release ticket for currently released product.
 *
 * @return {Record<string, any>[] | undefined} Generated set of message blocks.
 */
const releaseNotificationBlocks = (
  completed: boolean,
  release: ReleaseProcessOutcome,
  releaseVersion?: JIRAProjectRelease
): Record<string, any>[] | undefined => {
  let blocks: Record<string, any>[] = []
  const productName = releasedProductName(release)

  let headerMessage = `${!completed ? 'Preparing ' : ''}${productName} ${
    release.changelog?.version ? `${release.changelog.version} ` : ''}SDK ${
    !completed ? 'release :rocket:' : 'released :tada:'}`

  blocks.push(
    {
      'type': 'header',
      'text': {'type': 'plain_text', 'text': headerMessage, 'emoji': true}
    },
    {
      'type': 'section',
      'text': {'type': 'plain_text', 'text': 'Release includes following changes:'}
    }
  )

  // Add change log entries to list of changes.
  const changeBlock = changeLogBlock(release)
  if (!changeBlock) return undefined
  else {
    blocks.push(changeBlock.block)

    if (changeBlock.hasBreakingChanges) {
      blocks.push({
        'type': 'section',
        'text': {'type': 'mrkdwn', 'text': '*WARNING:* Release contains breaking changes!'}
      })
    }
  }

  if (completed && (checkReleaseProcessStepDone('pod', release)
    || checkReleaseProcessStepDone('packagist', release)
    || checkReleaseProcessStepDone('maven', release)
    || checkReleaseProcessStepDone('npm', release)
    || checkReleaseProcessStepDone('pub', release)
    || checkReleaseProcessStepDone('twine', release)
    || checkReleaseProcessStepDone('gem', release)
  )) {
    blocks.push({
      'type': 'context',
      'elements': [
        {
          'type': 'mrkdwn',
          'text': '*Note:* Product will appear in dependency manager indices as soon as indexation process will complete on them.'
        }
      ]
    })
  }

  // Add JIRA release ticket information (if available).
  const jiraBlock = jiraReleaseVersionBlock(releaseVersion)
  if (jiraBlock) blocks.push(jiraBlock)

  if (completed) {
    // Add GitHub release information (if available).
    const ghReleaseBlock = gitHubReleaseBlock(release)
    if (ghReleaseBlock) blocks.push(ghReleaseBlock)

    // Add GitHub pages information (if available).
    const ghPagesBlock = gitHubPagesBlock(release)
    if (ghPagesBlock) blocks.push(ghPagesBlock)
  }

  return blocks
}

/**
 * Transform provided change log entries into list.
 *
 * @param {ReleaseProcessOutcome} release Ongoing release process information.
 *
 * @return {{block: Record<string, any>, hasBreakingChanges: boolean} | undefined} Components which will produce bulleted list
 * in message.
 */
const changeLogBlock = (release: ReleaseProcessOutcome): { block: Record<string, any>, hasBreakingChanges: boolean } | undefined => {
  let entries: Record<string, any>[] = []
  let hasBreakingChanges: boolean = false

  if (!release.changelog || release.changelog.entries.length === 0) return undefined

  for (let change of release.changelog.entries) {
    let description = change.description || change.title
    if (description.endsWith('.'))
      description = description.slice(0, description.length - 1)
    if (!hasBreakingChanges && change.isBreaking) hasBreakingChanges = true

    entries.push({
      'type': 'rich_text_section',
      'elements': [{'type': 'text', 'text': capitalizedString(description)}]
    })
  }

  return {
    block: {
      type: 'rich_text',
      elements: [
        {
          type: 'rich_text_list',
          elements: entries,
          style: 'bullet',
          indent: 0
        }
      ]
    },
    hasBreakingChanges
  }
}

/**
 * Generate block which will present link to product release version in JIRA.
 *
 * @param {JIRAProjectRelease} releaseVersion Version fetched earlier basing on product name and released version.
 *
 * @return {Record<string, any> | undefined} Blocks for JIRA release version representation in message.
 */
const jiraReleaseVersionBlock = (releaseVersion?: JIRAProjectRelease): Record<string, any> | undefined => {
  if (!releaseVersion) return undefined

  return {
    'type': 'context',
    'elements': [
      {
        'type': 'image',
        'image_url': 'https://emoji.slack-edge.com/T024J4WT1/atlassian/62c643f0ec009af1.png',
        'alt_text': 'JIRA Release'
      },
      {
        'type': 'mrkdwn',
        'text': `*JIRA Release:* <${releaseVersion.url}|${releaseVersion.name.split('] ').pop()}>`
      }
    ]
  }
}

/**
 * Generate block which will present link to product GitHub release.
 *
 * @param {ReleaseProcessOutcome} release Ongoing release process information.
 *
 * @return {Record<string, any> | undefined} Blocks for GitHub release representation in message.
 */
const gitHubReleaseBlock = (release: ReleaseProcessOutcome): Record<string, any> | undefined => {
  if (!checkReleaseProcessStepDone('GitHub Release', release)) return undefined

  const releaseLink = `https://github.com/${action.repository.slug}/releases/tag/${release.changelog?.version}`

  return {
    'type': 'context',
    'elements': [
      {
        'type': 'image',
        'image_url': 'https://emoji.slack-edge.com/T024J4WT1/octocat/fd4f0fe8b3f8f426.png',
        'alt_text': 'GitHub Release'
      },
      {
        'type': 'mrkdwn',
        'text': `*GitHub Release:* <${releaseLink}|${release.changelog?.version}>`
      }
    ]
  }
}

/**
 * Generate block which will present link to product GitHub pages.
 *
 * @param {ReleaseProcessOutcome} release Ongoing release process information.
 *
 * @return {Record<string, any> | undefined} Blocks for GitHub pages representation in message.
 */
const gitHubPagesBlock = (release: ReleaseProcessOutcome): Record<string, any> | undefined => {
  if (!checkReleaseProcessStepDone('GitHub Pages', release)) return undefined

  const pagesLink = `https://${action.repository.owner}.github.io/${action.repository.repo}`

  return {
    'type': 'context',
    'elements': [
      {
        'type': 'image',
        'image_url': 'https://a.slack-edge.com/production-standard-emoji-assets/13.0/apple-large/1f4d9@2x.png',
        'alt_text': 'GitHub Pages'
      },
      {
        'type': 'mrkdwn',
        'text': `*GitHub Pages:* <${pagesLink}|${release.changelog?.version}>`
      }
    ]
  }
}
