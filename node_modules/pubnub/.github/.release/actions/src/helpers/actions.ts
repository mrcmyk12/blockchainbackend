import * as artifact from '@actions/artifact'
import * as github from '@actions/github'
import * as core from '@actions/core'
// @ts-ignore
import decompress from 'decompress'
import sodium from 'tweetsodium'
import path from 'path'
import fs from 'fs'
import {ACTION_WORKING_DIR_PATH, CHANGES_AUTHOR_NAME, CHANGES_AUTHOR_USERNAME} from '../constants'
import {ActionInformation, GitHubRelease, OperationOutcome, ReleaseProcessOutcome} from './types'
import {productPath, productsJSONPath, releaseProcessInformationFilePath} from './paths'
import {cloneUrl} from './github'

/** Trigger event information representation. */
export type EventInformation = OperationOutcome & {
  /** Comment body which should be parsed as command. */
  command: string

  /** GitHub username of user which sent command. */
  sender: string
}

/** Artifact download outcome representation. */
type ArtifactDownload = OperationOutcome & {
  /** Full path to location where artifact has been downloaded. */
  downloadPath: string
}

/**
 * Retrieve GitHub action input values.
 *
 * @param {string} name Name of field for which value should be retrieved.
 * @param {boolean} required Whether specified field required or not.
 * @param {boolean} defaultValue Default value if GitHub Action input doesn't have it.
 *
 * @return {string|undefined} Value stored under specified `name`.
 */
export const getActionInput = (
  name: string,
  required: boolean = false,
  defaultValue: string | undefined = undefined
): string => {
  let value: string | undefined = core.getInput(name, {required})

  if (!required && !value && defaultValue !== undefined) value = defaultValue

  return value
}

/**
 * Retrieve GitHub action boolean values.
 *
 * @param {string} name Name of field for which boolean value should be retrieved.
 * @param {boolean} required Whether specified field required or not.
 * @param {string} defaultValue Default boolean value if GitHub Action input doesn't have it.
 *
 * @return {boolean} Boolean value stored under specified `name`.
 */
export const getActionBooleanInput = (name: string, required: boolean = false, defaultValue: string = 'false'): boolean => {
  let value = getActionInput(name, required, defaultValue)

  if (['true', 'True', 'TRUE'].includes(value)) return true
  else if (['false', 'False', 'FALSE'].includes(value)) return false

  return false
}

/**
 * Update GitHub Action secret using Octokit.
 *
 * @param {string} token GitHub REST API access token with `repo` permissions.
 * @param {string} keyName Name of secret, for which value should be updated.
 * @param {string} value Value which should be set for secret.
 *
 * @return {Promise<{successful:boolean,message?:string,suggestion?:string}>} Asynchronous secret update results.
 */
export const setActionSecret = async (
  token: string,
  keyName: string,
  value: string
): Promise<{successful: boolean; message?: string; suggestion?: string}> => {
  const [owner, repo] = process.env['GITHUB_REPOSITORY']!.split('/')
  const octokit = github.getOctokit(token)
  let errorMessage: string | undefined
  let key, key_id: string | undefined
  let suggestion: string | undefined

  try {
    const publicKeyFetchResult = await octokit.request(
      'GET /repos/{owner}/{repo}/actions/secrets/public-key',
      {owner, repo}
    )
    key_id = publicKeyFetchResult.data.key_id
    key = publicKeyFetchResult.data.key
  } catch (error) {
    errorMessage = error.message
    suggestion = 'Ensure that provided GitHub token has required permissions.'
  }

  if (key) {
    const messageBytes = Buffer.from(value)
    const keyBytes = Buffer.from(key, 'base64')
    const encryptedBytes = sodium.seal(messageBytes, keyBytes)
    const encrypted = Buffer.from(encryptedBytes).toString('base64')
    try {
      await octokit.request(
        'PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}',
        {owner, repo, secret_name: keyName, key_id: key_id, encrypted_value: encrypted}
      )
    } catch (error) {
      errorMessage = error.message
      suggestion = 'Ensure that provided GitHub token has required permissions.'
    }
  }

  return {successful: !errorMessage, message: errorMessage, suggestion: errorMessage ? suggestion : undefined}
}

/**
 * Parse stored event information JSON to pull out required data from it.
 *
 * @param {boolean} commentEvent Whether processed event triggered by comments or not.
 *
 * @return {EventInformation} Information about command and who sent it or error in case if event can't be processed.
 */
export const getEventInformation = (commentEvent: boolean = false): EventInformation => {
  let errorMessage, errorSuggestion: string | undefined
  let command, sender: string | undefined

  if (!process.env['GITHUB_EVENT_PATH']) {
    errorMessage = 'Event description JSON path not set.'
    errorSuggestion =
      'Ensure that there is no typos in used environment variable name.'
  } else {
    const eventContent = fs.readFileSync(process.env['GITHUB_EVENT_PATH']).toString('utf8')

    if (eventContent) {
      const eventJSON = JSON.parse(eventContent)

      if (commentEvent) {
        if (eventJSON.comment && eventJSON.comment.body) command = eventJSON.comment.body
        else {
          errorMessage = 'Comment information is missing.'
          errorSuggestion =
            'Ensure that triggering event provide this field for webhook.'
        }
      }

      if (eventJSON.sender && eventJSON.sender.login) sender = eventJSON.sender.login
      else {
        errorMessage = 'Comment sender information is missing.'
        errorSuggestion =
          'Ensure that triggering event provide this field for webhook.'
      }
    } else {
      errorMessage = `'${path.basename(process.env['GITHUB_EVENT_PATH'])}' is empty or contains non-UTF8 characters.`
      errorSuggestion = 'Ensure that file not empty and contains only valid characters.'
    }
  }

  return {successful: !errorSuggestion, sender: sender ?? '', command: command ?? '', errorMessage, errorSuggestion}
}

/**
 * Upload specified data as artifact.
 *
 * @param {string} data Data which should be uploaded as  artifact.
 * @param {string} name Name under which data will be stored.
 *
 * @return {Promise<OperationOutcome>} Asynchronous artifact upload result.
 */
export const uploadArtifact = async (data: string, name: string): Promise<OperationOutcome> => {
  const rootDirectory = process.env['GITHUB_WORKSPACE']!
  const dataPath = path.join(rootDirectory, ACTION_WORKING_DIR_PATH, name)
  const artifactName = name.replace(path.extname(name), '')
  let errorSuggestion: string | undefined
  let errorMessage: string | undefined

  // Create directories structure (if required).
  if (!fs.existsSync(path.dirname(dataPath)))
    fs.mkdirSync(path.dirname(dataPath), {recursive: true})
  fs.writeFileSync(dataPath, data)

  try {
    const artifactClient = artifact.create()
    await artifactClient.uploadArtifact(
      artifactName,
      [dataPath],
      rootDirectory,
      {retentionDays: 2}
    )
  } catch (error) {
    errorMessage = `${name} upload failed: ${error.message}`
    errorSuggestion = 'Check permissions and review error message.'
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Download specified artifact files.
 *
 * @param {string} token GitHub REST API access token with `repo` permissions.
 * @param {string} name Name under which data has been be stored.
 *
 * @return {Promise<ArtifactDownload>} Asynchronous artifact upload result.
 */
export const downloadArtifact = async (token: string, name: string): Promise<ArtifactDownload> => {
  const [owner, repo] = process.env['GITHUB_REPOSITORY']!.split('/')
  const rootDirectory = process.env['GITHUB_WORKSPACE']!
  const artifactName = name.replace(path.extname(name), '')
  let artifacts: {id: number}[] | undefined
  const octokit = github.getOctokit(token)
  let errorSuggestion: string | undefined
  let errorMessage: string | undefined

  // Create directories structure (if required).
  if (!fs.existsSync(rootDirectory)) fs.mkdirSync(rootDirectory, {recursive: true})

  // Download list of artifacts.
  try {
    const response = await octokit.request(
      'GET /repos/{owner}/{repo}/actions/artifacts',
      {owner, repo, per_page: 100}
    )
    artifacts = response.data.artifacts.filter(fetchedArtifact => fetchedArtifact.name === artifactName)
  } catch (error) {
    errorMessage = `${repo} release artifacts list fetch failed: ${error.message}`
    errorSuggestion = 'Check permissions and review error message.'
  }

  if (!errorMessage && artifacts && artifacts.length) {
    // Download list of artifacts.
    try {
      const response = await octokit.request(
        'GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}',
        {owner, repo, artifact_id: artifacts[0].id, archive_format: 'zip'}
      )

      const archivePath = `${rootDirectory}/${artifactName}.zip`
      // @ts-ignore Storing binary data to file for decompression.
      fs.writeFileSync(archivePath, new Uint8Array(response.data))

      // Decompress archive and get list of files.
      const decompressed: { path: string; data: Buffer }[] = (await decompress(archivePath)) || []

      // Filter out only files from decompressed archive.
      const decompressedFiles = decompressed.filter(file => !file.path.endsWith('/') && file.data.length)

      // Write unarchived files.
      for (const decompressedFile of decompressedFiles) {
        const filePath = `${rootDirectory}/${decompressedFile.path}`
        if (!fs.existsSync(path.dirname(filePath)))
          fs.mkdirSync(path.dirname(filePath), {recursive: true})
        fs.writeFileSync(filePath, decompressedFile.data)
      }
    } catch (error) {
      errorMessage = `${name} download failed: ${error.message}`
      errorSuggestion = 'Check permissions and review error message.'
    }
  } else if (!errorMessage) {
    errorMessage = `${artifactName} release artifact not listed for ${repo} repository`
    errorSuggestion = 'Build completed more that after 24h or release never happened.'
  }

  return {
    downloadPath: path.join(rootDirectory, ACTION_WORKING_DIR_PATH),
    successful: !errorMessage,
    errorMessage,
    errorSuggestion
  }
}

/**
 * Upload list of artifacts to specified GitHub Release.
 * Required permissions on extended token: 'releases' (write)
 *
 * @param {string} artifactsPath Full path to artifacts location.
 * @param {GitHubRelease} release Information on GitHub Release for which upload will be done.
 *
 * @return {Promise<OperationOutcome>} Asynchronous results of artifacts upload.
 */
export const uploadArtifactsForRelease = async (artifactsPath: string, release: GitHubRelease): Promise<OperationOutcome> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const token: string = action.github.ghToken || action.github.token
  let errorMessage, errorSuggestion: string | undefined
  const artifactNames = fs.readdirSync(artifactsPath)
  const octokit = github.getOctokit(token)

  for (let artifactName of artifactNames) {
    const artifactPath = path.join(artifactsPath, artifactName)
    const artifact = fs.readFileSync(artifactPath)
    const artifactStats = fs.statSync(artifactPath)
    const artifactSize = artifactStats.size;

    try {
      await octokit.rest.repos.uploadReleaseAsset({
        url: `${release.uploadUrl}?name=${artifactName}`,
        headers: {'content-type': 'binary/octet-stream', 'content-length': artifactSize},
        name: artifactName,
        // @ts-ignore
        data: artifact
      })
    } catch (error) {
      errorMessage = `Unable to upload artifact: ${error}`
      errorSuggestion =
        'Ensure that provided token has permissions to upload artifacts for GitHub releases.'
    }

    if (errorMessage) break
  }

  if (!errorMessage && release.id) {
    const [owner, repo] = process.env['GITHUB_REPOSITORY']!.split('/')

    try {
      await octokit.request(
        'PATCH /repos/{owner}/{repo}/releases/{release_id}',
        {owner, repo, release_id: release.id, draft: false}
      )
    } catch (error) {
      errorMessage = `Unable to switch from draft to public release: ${error}`
      errorSuggestion =
        'Ensure that provided token has permissions to upload artifacts for GitHub releases.'
    }
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Download release artifacts for specified PR.
 * Required permissions on extended token: 'releases' (read)
 *
 * @param {number} number Number of PR which has been used to trigger deployment workflow.
 *
 * @return {Promise<ReleaseProcessOutcome>} Asynchronous results of release artifacts download.
 */
export const downloadReleaseProcessInformation = async (number: number): Promise<ReleaseProcessOutcome> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const decidedToken: string = action.github.ghToken || action.github.token
  const artifactFilename = `release-artifacts-${number}.json`
  const downloadOutcome = await downloadArtifact(decidedToken, artifactFilename)
  let outcome: ReleaseProcessOutcome = {successful: true, completedSteps: []}

  if (downloadOutcome.successful) {
    const artifactPath = path.join(downloadOutcome.downloadPath, artifactFilename)

    if (fs.existsSync(artifactPath)) {
      const artifactContent = fs.readFileSync(artifactPath).toString('utf8')
      if (artifactContent) {
        outcome = {...outcome, ...JSON.parse(artifactContent)}
        if (artifactPath !== releaseProcessInformationFilePath()) fs.copyFileSync(artifactPath, releaseProcessInformationFilePath())
      }
      else {
        outcome.errorMessage = 'Release artifact data malformed.'
        outcome.errorSuggestion = 'Previous release process end up with error and uploaded malformed artifact.'
      }
    } else {
      outcome.errorMessage = 'Unable to download artifact.'
      outcome.errorSuggestion = 'Release artifact is too old and has been removed.'
    }
  } else outcome = {...outcome, ...downloadOutcome}

  outcome.successful = !outcome.errorMessage

  return outcome
}

/**
 * Complete action setup with information prepared during release request processing.
 *
 * @param {number} number Number of PR which has been used to trigger deployment workflow.
 *
 * @return {Promise<ReleaseProcessOutcome>} Asynchronously retrieved prepared release information.
 */
export const setupFromReleaseArtifact = async (number: number): Promise<ReleaseProcessOutcome> => {
  const downloadOutcome = await downloadReleaseProcessInformation(number)

  if (downloadOutcome.successful && downloadOutcome.product) {
    // Check whether product information available and can be used to complete paths setup.
    const pathToProject = path.join(action.rootWorkingDirectory, ACTION_WORKING_DIR_PATH, 'product-path')
    fs.writeFileSync(pathToProject, downloadOutcome.product.path, {encoding: 'utf8'})

    // Store product directory.
    action.productWorkingDirectory = workingDirectory()
  }

  return downloadOutcome
}

/**
 * Mark specific release process step as done.
 *
 * @param {string} step Name of steps which should be marked as done.
 * @param {ReleaseProcessOutcome} releaseProcessInformation Object with information about current release process and
 * completed steps.
 *
 * @return {Promise<OperationOutcome>} Asynchronous results of steps
 */
export const releaseProcessMarkStepDone = (
  step: string,
  releaseProcessInformation: ReleaseProcessOutcome
) => {
  if (!releaseProcessInformation.completedSteps.includes(step)) {
    releaseProcessInformation.completedSteps.push(step)

    fs.writeFileSync(releaseProcessInformationFilePath(), JSON.stringify(releaseProcessInformation), {encoding: 'utf8'})
  }
}

/**
 * Check whether specified release step already completed or not.
 *
 * @param {string} step One of release step names which should be checked.
 * @param {ReleaseProcessOutcome} releaseProcessInformation Object with information about current release process and
 * completed steps.
 *
 * @return {boolean} Whether specified `step` has been completed already or not.
 */
export const checkReleaseProcessStepDone = (
  step: string,
  releaseProcessInformation: ReleaseProcessOutcome
): boolean => (releaseProcessInformation.completedSteps ?? []).includes(step)

/**
 * Retrieve full path to project working directory, taking into account product path in case of monorepo.
 *
 * @param {boolean} forRepository Whether working directory for repository itself should be retrieved.
 *
 * @return {string} Target product working directory.
 */
export const workingDirectory = (forRepository: boolean = false): string => {
  let workspace = process.env['GITHUB_WORKSPACE']!

  return !forRepository ? path.join(workspace, productPath()) : workspace
}

/**
 * Retrieve information about currently processed product.
 *
 * @param {string} product product identifier for which information will be returned.
 *
 * @return {{path: string, name: string, main: boolean} | undefined | null} Product information object if exists.
 */
export const productInformation = (product: string): { path: string, name: string, main: boolean } | undefined | null => {
  const productsFilePath = productsJSONPath()

  if (productsFilePath && fs.existsSync(productsFilePath)) {
    const productsContent = fs.readFileSync(productsFilePath).toString('utf8')

    if (productsContent) {
      const projectsJSON: Record<string, { path: string; name: string, main: boolean }> = JSON.parse(productsContent) || {}

      if (projectsJSON[product]) return projectsJSON[product]
      else return undefined
    }
  }

  return null
}

/**
 * Extract server host host name from provided URL.
 *
 * @param {string} url Environment variable which represent URL of servers on which action triggered.
 *
 * @return {string} Server host name.
 */
export const getHostnameFromUrl = (url: string): string =>
  url.replace(/^(?:https?:\/\/)?(?:www\.)?/g, '').split('/')[0]

const ghToken = getActionInput('github-token', false)
const token = getActionInput('token', false)
const isIssueOrPullRequest = github.context.payload.issue !== undefined
  || github.context.payload.pull_request !== undefined

// Hiding tokens from console output.
if (ghToken) core.setSecret(ghToken)
if (token) core.setSecret(token)

/** GitHub Action runner information. */
export const action: ActionInformation = {
  github: {
    ghToken: getActionInput('github-token', false),
    token: getActionInput('token', false),
    hostname: getHostnameFromUrl(github.context.serverUrl)
  },
  bot: {name: CHANGES_AUTHOR_NAME, username: CHANGES_AUTHOR_USERNAME},
  repository: {
    ...github.context.repo,
    slug: process.env['GITHUB_REPOSITORY']!,
    cloneUrl: `https://x-access-token:${getActionInput(
      'github-token',
      false
    )}@${getHostnameFromUrl(github.context.serverUrl)}/${process.env[
      'GITHUB_REPOSITORY'
    ]!}.git`
  },
  isRegularPush: !isIssueOrPullRequest,
  issue: isIssueOrPullRequest ? {
    type: github.context.payload.comment ? 'issue-comment' : github.context.payload.pull_request ? 'pull-request' : 'issue',
    number: github.context.issue.number,
    title: (github.context.payload.issue || github.context.payload.pull_request)!['title'] as string,
    body: (github.context.payload.issue || github.context.payload.pull_request)!['body'] as string,
    state: (github.context.payload.issue || github.context.payload.pull_request)!['body'] as ActionInformation['issue']['state'],
    creator: (github.context.payload.issue || github.context.payload.pull_request)!['user'].login as string,
    head: github.context.payload.pull_request ? {
      ref: github.context.payload.pull_request['head'].ref,
      owner: github.context.payload.pull_request['head'].repo.owner.login.toLowerCase(),
      repo: github.context.payload.pull_request['head'].repo.name.toLowerCase(),
      fork: github.context.payload.pull_request['head'].repo.fork,
      cloneUrl: cloneUrl(ghToken || token, github.context.payload.pull_request['head'].repo.clone_url)
    } : {ref: '', owner: '', repo: '', fork: true, cloneUrl: ''},
    base: github.context.payload.pull_request ? {
      ref: github.context.payload.pull_request['base'].ref,
      owner: github.context.payload.pull_request['base'].repo.owner.login.toLowerCase(),
      repo: github.context.payload.pull_request['base'].repo.name.toLowerCase(),
      cloneUrl: cloneUrl(ghToken || token, github.context.payload.pull_request['base'].repo.clone_url)
    } : {ref: '', owner: '', repo: '', cloneUrl: ''},
    comment: github.context.payload.comment ? {
        author: {username: github.context.payload.comment['user'].login, ownerOrMember: false},
        body: github.context.payload.comment['body']
      }
      : {author: {username: '', ownerOrMember: false}, body: ''}
  } : {
    type: 'issue',
    number: 0,
    title: 'unknown',
    body: 'no body',
    state: 'open',
    creator: 'PubNub',
    isPullRequest: false
  },
  rootWorkingDirectory: workingDirectory(true),
  productWorkingDirectory: workingDirectory() ?? workingDirectory(true)
}
