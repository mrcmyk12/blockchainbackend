import * as http from '@actions/http-client'
import * as core from '@actions/core'
import * as tc from '@actions/tool-cache'
import {gte, clean, rcompare} from 'semver'
import path from 'path'
import os from 'os'
import fs from 'fs'
import {cliCheck, cliExec, cliVersion} from '../helpers/cli'

/** Installed Dart / Flutter check result representation. */
export type PubCheckResult = {
  /** Whether Dart / Flutter installed and match version expectations or not. */
  match: boolean

  /** Detected Dart / Flutter version. */
  version?: string

  /** For case when Dart / Flutter doesn't match expectations, will contain reason. */
  errorMessage?: string

  /** Potential issue fix suggestion. */
  errorSuggestion?: string
}

/** Flutter installation results representation. */
export type FlutterInstallResult = {
  /** Whether required Flutter version installed successfully or not. */
  successful: boolean

  /** For case when Dart / Flutter doesn't match expectations, will contain reason. */
  errorMessage?: string

  /** Potential issue fix suggestion. */
  errorSuggestion?: string
}

type FlutterReleasesResponse = {
  /** Flutter packages base download URL. */
  base_url: string
  /** Latest release hashes by deployment channel names. */
  current_release: { beta: string; dev: string; stable: string }
  releases: { hash: string; channel: string; version: string; archive: string }[]
}

/** Base object which represent Flutter release search response. */
type FlutterReleaseResponse = {
  /** Release which has been discovered. */
  release?: (FlutterReleasesResponse['releases'][number] & { url?: string, rawVersion?: string })

  /** Service error message (if failed). */
  errorMessage?: string

  /** What can be done to fix error. */
  errorSuggestion?: string
}

const platform = (): string => {
  let {platform} = process

  if (platform === 'win32') return 'windows'
  else if (platform === 'darwin') return 'macos'
  return platform
}

/**
 * Retrieve list of Flutter releases matching specified version.
 *
 * @param {string} version Version for which releases should be found.
 * @param {FlutterReleasesResponse['releases']} releases List of releases which should be filtered.
 *
 * @return {FlutterReleasesResponse['releases']} Filtered Flutter releases.
 */
const matchedFlutterReleases = (
  version: string,
  releases: FlutterReleasesResponse['releases']
): FlutterReleasesResponse['releases'] => {
  const wildCardVersion = version.endsWith('.x')

  if (!version) return releases
  else if (wildCardVersion) version = version.substring(0, version.length - 2)

  releases = releases.filter(release =>
    release.version.startsWith('v')
      ? wildCardVersion
      ? release.version.startsWith(`v${version}`)
      : release.version === `v${version}`
      : wildCardVersion
      ? release.version.startsWith(version)
      : release.version === version
  )

  if (wildCardVersion)
    releases = releases.sort((rel1, rel2) =>
      rcompare(clean(rel1.version)!, clean(rel2.version)!)
    )

  return releases
}

/**
 * Retrieve Flutter release information.
 *
 * @param {string} version Expected version to install. Empty string for latest version.
 * @param {'stable'|'dev'|'beta'|'any'} channel Release channel in which specified version should be found.
 *
 * @release {Promise<FlutterReleaseResponse>} Asynchronously resolved Flutter release information.
 */
const flutterRelease = async (
  version: string,
  channel: 'stable' | 'dev' | 'beta' | 'any'
): Promise<FlutterReleaseResponse> => {
  let release: FlutterReleasesResponse['releases'][number] | undefined
  const client = new http.HttpClient('deploy-http-client')
  let errorMessage, errorSuggestion: string | undefined
  let rawVersion: string | undefined
  let url: string | undefined

  try {
    const releases: FlutterReleasesResponse | null = (
      await client.getJson<FlutterReleasesResponse>(
        `https://storage.googleapis.com/flutter_infra_release/releases/releases_${platform()}.json`
      )
    ).result

    if (releases !== null) {
      const matchedReleases = version
        ? matchedFlutterReleases(version, releases.releases)
        : releases.releases
      release = matchedReleases.find(
        rel =>
          (version && (channel === 'any' || rel.channel === channel)) ||
          (channel !== 'any' && rel.hash === releases.current_release[channel])
      )

      if (release) {
        url = `${releases.base_url}/${release.archive}`
        rawVersion = release.version
        release.version = rawVersion.startsWith('v') ? rawVersion.substring(1) : rawVersion
      } else {
        errorMessage = 'Release matching specified requirements not found.'
        errorSuggestion = 'Check which versions available in specified channel or set channel to \'any\'.'
      }
    }
  } catch (error) {
    errorMessage = error.message
    errorSuggestion = 'Platform not supported or server with releases not available.'
  }

  return {release: release ? {...release, url, rawVersion} : undefined, errorMessage, errorSuggestion}
}

/**
 * Actual Dart installation should be done using `dart-lang/setup-dart@v1` which takes
 * care of architecture, OS type.
 * This function verify that minimum required version installed.
 *
 * @param {number} major Minimum major version which should be installed on container.
 * @param {number?} minor Minimum minor version which should be installed on container.
 * @param {number?} patch Minimum patch version which should be installed on container.
 *
 * @return {Promise<PubCheckResult>} Asynchronous Dart check results.
 */
export const checkDartVersion = async (major: number, minor?: number, patch?: number): Promise<PubCheckResult> => {
  const expectedVersion = `${major}.${minor ?? 0}.${patch ?? 0}`
  let errorMessage: string | undefined
  let version: string | undefined

  const checkResult = await cliCheck({cli: 'dart', commandOrFlags: ['--version']})

  // Extract Dart version from `dart --version` output.
  if (checkResult.available) version = cliVersion(checkResult.output, /.*version:\s?([a-z0-9.-]*)/m)

  if (version && !gte(version, expectedVersion)) {
    errorMessage = `Outdated Dart ${version} installed.`
    version = expectedVersion
  } else if (!version) {
    version = `${major}.${minor ?? 'x'}${patch ? `.${patch}` : ''}`
    errorMessage = 'Dart not installed.'
  }

  return {
    match: !errorMessage,
    version,
    errorMessage,
    errorSuggestion: errorMessage ? `Use 'dart-lang/setup-dart@v1' to install Ruby '${version}'.` : undefined
  }
}

/**
 * Actual Flutter installation should be done using `dart-lang/setup-dart@v1` which takes
 * care of architecture, OS type.
 * This function verify that minimum required version installed.
 *
 * @param {number} major Minimum major version which should be installed on container.
 * @param {number?} minor Minimum minor version which should be installed on container.
 * @param {number?} patch Minimum patch version which should be installed on container.
 *
 * @return {Promise<PubCheckResult>} Asynchronous Flutter check results.
 */
export const checkFlutterVersion = async (major: number, minor?: number, patch?: number): Promise<PubCheckResult> => {
  const expectedVersion = `${major}.${minor ?? 0}.${patch ?? 0}`
  let errorMessage: string | undefined
  let version: string | undefined

  const checkResult = await cliCheck({cli: 'flutter', commandOrFlags: ['--version']})

  // Extract Dart version from `flutter --version` output.
  if (checkResult.available) version = cliVersion(checkResult.output, /^Flutter\s?([a-z0-9.-]*)/m)

  if (version && !gte(version, expectedVersion)) {
    errorMessage = `Outdated Flutter ${version} installed.`
    version = expectedVersion
  } else if (!version) {
    version = `${major}.${minor ?? 'x'}${patch ? `.${patch}` : ''}`
    errorMessage = 'Flutter not installed.'
  }

  return {match: !errorMessage, version, errorMessage}
}

/**
 * Install specified Flutter version on machine.
 *
 * @param {string} version Flutter version to install.
 * @param {string} channel Build release channel.
 */
export const installFlutter = async (
  version: string,
  channel: 'stable' | 'dev' | 'beta' | 'any' | 'master'
): Promise<FlutterInstallResult> => {
  let errorMessage, errorSuggestion: string | undefined
  let pubCachePath = process.env['PUB_CACHE'] || ''
  if (channel === 'master') channel = 'dev'

  const releaseData: FlutterReleaseResponse | undefined = await flutterRelease(version, channel)

  if (releaseData.release) {
    const {release} = releaseData
    const cacheId = channel === 'dev' ? channel : `${release.version}-${release.channel}`
    let toolPath = tc.find('flutter', cacheId)

    if (!toolPath && release.url) {
      const archive = await tc.downloadTool(release.url)
      const cache = process.env['RUNNER_TEMP'] ? path.join(process.env['RUNNER_TEMP'], 'actions', 'tmp') : os.tmpdir()
      const fileStats = fs.statSync(path.normalize(archive))

      if (fileStats.isFile()) {
        try {
          if (archive.endsWith('tar.xz')) await tc.extractTar(archive, cache, 'x')
          else await tc.extractZip(archive, cache)
        } catch (error) {
          errorMessage = error.message
          errorSuggestion = `Runner is out of space or unsupported archive has been used: ${archive}`
        }
      }

      const flutterPath = path.join(cache, fs.readdirSync(cache)[0])
      toolPath = await tc.cacheDir(flutterPath, 'flutter', cacheId)
    }
    core.exportVariable('FLUTTER_ROOT', toolPath)

    if (!pubCachePath) {
      pubCachePath = path.join(toolPath, '.pub-cache')
      core.exportVariable('PUB_CACHE', pubCachePath)
    }

    core.addPath(path.join(toolPath, 'bin'))
    core.addPath(path.join(toolPath, 'bin', 'cache', 'dart-sdk', 'bin'))
    core.addPath(path.join(pubCachePath, 'bin'))

    if (channel === 'dev') {
      await cliExec({cli: 'flutter', commandOrFlags: ['channel', 'master']})
      await cliExec({cli: 'flutter', commandOrFlags: ['upgrade']})
    }
  } else {
    errorMessage = releaseData.errorMessage
    errorSuggestion = releaseData.errorSuggestion
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}
