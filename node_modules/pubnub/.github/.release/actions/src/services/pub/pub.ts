import path from 'path'
import fs from 'fs'
import {checkDartVersion, checkFlutterVersion, installFlutter} from '../../installers/install-pub'
import {action, getActionInput, setActionSecret} from '../../helpers/actions'
import {OperationOutcome} from '../../helpers/types'
import {cliExec} from '../../helpers/cli'
import * as log from '../../helpers/log'
import * as Service from '../service'

type FlutterReleaseChannel = 'stable' | 'dev' | 'beta' | 'any' | 'master'

/** Pub service package handler. */
class PubService extends Service.ServiceBase {
  /**
   * Whether Flutter should be installed.
   * This information used if built project is Flutter package.
   * @private
   */
  private shouldInstallFlutter: boolean = false

  /**
   * Name of channel from which latest / requested version of flutter should be installed.
   * This information used if built project is Flutter package.
   * @private
   */
  private flutterChannel!: FlutterReleaseChannel

  /**
   * Version of flutter which should be installed.
   * This information used if built project is Flutter package.
   * @private
   */
  private flutterVersion!: string

  /**
   * URI of endpoint which issues access token.
   * Value became available after release from local machine and stored in ~/.pub-cache/credentials.json
   * @private
   */
  private tokenEndpoint!: string

  /**
   * Token expiration unix-timestamp.
   * Value became available after release from local machine and stored in ~/.pub-cache/credentials.json
   * @private
   */
  private tokenExpiration!: string

  /**
   * Pub account access token refresh token.
   * Value became available after release from local machine and stored in ~/.pub-cache/credentials.json
   * @private
   */
  private refreshToken!: string

  /**
   * Pub account access token.
   * Value became available after release from local machine and stored in ~/.pub-cache/credentials.json
   * @private
   */
  private accessToken!: string

  /** Full path to pubspec file which should be used during package publish. */
  private specPath?: string

  /** Type of package discovered from pubspec file content. */
  private pubType!: string

  constructor() {
    super()

    // Dependencies should be installed before publish.
    this.shouldSetupServiceEnvironment = true
  }

  serviceName(): string {
    return 'pub'
  }

  secretValues(): string[] {
    return [this.accessToken, this.refreshToken]
  }

  environmentVariables(): Record<string, any> {
    return {}
  }

  readInput(): void {
    this.tokenEndpoint = getActionInput('pub-token-endpoint', true)
    this.refreshToken = getActionInput('pub-refresh-token', true)
    this.accessToken = getActionInput('pub-access-token', true)
    this.tokenExpiration = getActionInput('pub-token-expiration', true)
    this.flutterVersion = getActionInput('flutter-version', false, '')
    this.flutterChannel = getActionInput('flutter-channel', false, 'stable') as FlutterReleaseChannel
    this.specPath = this.filePath({name: 'pubspec.yaml'}, getActionInput('pub-spec-path', false))
  }

  async verifyInput(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    if (!this.specPath) errorMessage = 'Pub spec file not set.'
    else if (!fs.existsSync(this.specPath)) {
      errorMessage = `'${path.basename(this.specPath)}' file not found: ${path.dirname(this.specPath)}`
      errorSuggestion = 'Make sure that proper relative path has been set (present in product directory for monorepo).'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  // @ts-ignore Async doesn't override properly.
  async updateServiceSettings(): Promise<OperationOutcome> {
    const outcome = await super.updateServiceSettings()

    if (outcome.successful) {
      const pubConfigPath = path.join(process.env['HOME']!, '.pub-cache/credentials.json')

      this.markChangedSettingsFile(pubConfigPath)

      const configuration = {
        accessToken: this.accessToken,
        refreshToken: this.refreshToken,
        tokenEndpoint: this.tokenEndpoint,
        scopes: ['openid', 'https://www.googleapis.com/auth/userinfo.email'],
        expiration: this.tokenExpiration
      }

      fs.writeFileSync(pubConfigPath, JSON.stringify(configuration), {encoding: 'utf8'})
    }

    return outcome
  }

  async verifyServiceEnvironment(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    if (this.pubType === 'dart') {
      const checkResult = await checkDartVersion(2, 12)
      if (!checkResult.match) {
        errorMessage = checkResult.errorMessage
        errorSuggestion = checkResult.errorSuggestion
      }
    } else this.shouldInstallFlutter = !(await checkFlutterVersion(2, 12, 0)).match

    return {
      successful: !errorMessage,
      errorMessage,
      errorSuggestion: errorMessage ? errorSuggestion : undefined
    }
  }

  async setupServiceEnvironment(): Promise<OperationOutcome> {
    const cli = this.pubType === 'dart' ? 'pub' : 'flutter'
    let errorMessage, errorSuggestion: string | undefined
    let commandOrFlags = ['get']

    if (this.shouldInstallFlutter) {
      const installResult = await installFlutter(
        this.flutterVersion,
        this.flutterChannel
      )

      if (installResult.errorMessage) {
        errorMessage = installResult.errorMessage
        errorSuggestion = installResult.errorSuggestion
      }
    }

    if (!errorMessage) {
      if (this.pubType === 'flutter') commandOrFlags.unshift('pub')
      const getResult = await cliExec({cli, commandOrFlags})

      if (getResult.code !== 0) {
        errorMessage = `'${cli} ${commandOrFlags.join(' ')}' failed: ${getResult.stderr || getResult.stdout}`
        errorSuggestion = 'Ensure that there is no errors in dependency names.'
      }
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  async fetchPackageInformation(): Promise<OperationOutcome> {
    const pubspecContent = fs.readFileSync(this.specPath!).toString('utf8')
    let errorMessage, errorSuggestion: string | undefined

    if (pubspecContent) {
      const matchedName = pubspecContent.match(/^name:\s?([a-z0-9.-]*)$/m)

      if (!matchedName || matchedName.length <= 1) {
        errorMessage = `'name' is missing from pub spec: ${this.specPath}`
        errorSuggestion = 'Make sure that required field is present in pub spec.'
      } else this.packageName = matchedName[1]

      if (!errorMessage) {
        const matchedVersion = pubspecContent.match(/^version:\s?([a-z0-9.-]*)$/m)

        if (!matchedVersion || matchedVersion.length <= 1) {
          errorMessage = `'version' is missing from pub spec: ${this.specPath}`
          errorSuggestion = 'Make sure that required field is present in pub spec.'
        } else this.packageVersion = matchedVersion[1]
      }

      if (!errorMessage) {
        if (new RegExp('^.*sdk: flutter$', 'm').test(pubspecContent)) this.pubType = 'flutter'
        else this.pubType = 'dart'
      }
    } else {
      errorMessage = `'${path.basename(this.specPath!)}' is empty or contains non-UTF8 characters.`
      errorSuggestion = 'Ensure that file not empty and contains only valid characters.'
    }

    if (!errorMessage) {
      const changelogPath = this.productPath('CHANGELOG.md', true)
      const changelogContent = fs.readFileSync(changelogPath).toString('utf8')

      if (changelogContent && !new RegExp(this.packageVersion!, 'm').test(changelogContent)) {
        errorMessage = `'CHANGELOG.md' doesn't mention current version: ${this.packageVersion}`
      } else if (!changelogContent) {
        errorMessage = `'CHANGELOG.md' file is missing: ${changelogPath}`
        errorSuggestion = 'Ensure that required \'CHANGELOG.md\' is present in directory with used \'pubspec.yml\'.'
      }
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  override preBuildUserScript(): string {
    return 'pre-pub-build'
  }

  override prePublishUserScript(): string {
    return 'pre-pub-publish'
  }

  async publish(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    const cli = this.pubType === 'dart' ? 'pub' : 'flutter'
    let commandOrFlags = ['publish', '--force']

    if (this.pubType === 'flutter') commandOrFlags.unshift('dart')

    const publishResult = await cliExec({cli, commandOrFlags})

    if (publishResult.code === 0) {
      const updateCredentialsResult = await this.updateCredentialsInSecrets()

      if (!updateCredentialsResult.successful) {
        errorMessage = updateCredentialsResult.errorMessage
        errorSuggestion = updateCredentialsResult.errorSuggestion
      }
    } else {
      errorMessage = `Package publish failed: ${publishResult.stderr || publishResult.stdout}`
      errorSuggestion = 'Review publish log and command output.'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  /**
   * Update GitHub Action secrets if any token information has been changed.
   * @private
   */
  private async updateCredentialsInSecrets(): Promise<OperationOutcome> {
    // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
    const token: string = action.github.ghToken || action.github.token
    let errorMessage, errorSuggestion: string | undefined

    const pubConfigPath = path.join(process.env['HOME']!, 'credentials.json')
    const configurationContent = fs.readFileSync(pubConfigPath).toString('utf8')

    log.info('Update GitHub Actions Secrets')
    if (configurationContent) {
      const configuration = JSON.parse(configurationContent)

      if (configuration['accessToken'] && configuration['accessToken'] !== this.accessToken) {
        log.info('Updating \'DART_ACCESS_TOKEN\' GitHub Action secret')
        const result = await setActionSecret(token, 'DART_ACCESS_TOKEN', configuration['accessToken'])
        errorSuggestion = result.suggestion
        errorMessage = result.message
      }

      if (!errorMessage && configuration['refreshToken'] && configuration['refreshToken'] !== this.refreshToken) {
        log.info('Updating \'DART_REFRESH_TOKEN\' GitHub Action secret')
        const result = await setActionSecret(token, 'DART_REFRESH_TOKEN', configuration['refreshToken'])
        errorSuggestion = result.suggestion
        errorMessage = result.message
      }

      if (!errorMessage && configuration['tokenEndpoint'] && configuration['tokenEndpoint'] !== this.tokenEndpoint) {
        log.info('Updating \'DART_TOKEN_ENDPOINT\' GitHub Action secret')
        const result = await setActionSecret(token, 'DART_TOKEN_ENDPOINT', configuration['tokenEndpoint'])
        errorSuggestion = result.suggestion
        errorMessage = result.message
      }

      if (!errorMessage && configuration['expiration'] && configuration['expiration'] !== this.tokenExpiration) {
        log.info('Updating \'DART_TOKEN_EXPIRATION\' GitHub Action secret')
        const result = await setActionSecret(token, 'DART_TOKEN_EXPIRATION', configuration['expiration'])
        errorSuggestion = result.suggestion
        errorMessage = result.message
      }
    } else errorMessage = `Credentials file not found: ${pubConfigPath}`

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }
}

/** GitHub action runner entry point. */
async function run(): Promise<void> {
  await PubService.actionRunner(new PubService())
}

run()
