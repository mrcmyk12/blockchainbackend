import fse from 'fs-extra'
import path from 'path'
import fs from 'fs'
import {getActionBooleanInput, getActionInput} from '../../helpers/actions'
import {OperationOutcome} from '../../helpers/types'
import {UPLOAD_FOLDER_PATH} from '../../constants'
import {cliExec} from '../../helpers/cli'
import * as Service from '../service'

/** NPM service package handler. */
class NPMService extends Service.ServiceBase {
  /** Whether NPM package ownership should be checked before publish or not. */
  private checkOwnership!: boolean

  /** Full path to package.json which describes released package. */
  private packagePath!: string

  /** Command which should be used to build sources for upload. */
  private buildCommand!: string

  /** What actions should be performed. Available values: "publish" (to NPM) and "build" (locally for upload). */
  private actions!: ('publish' | 'build')[]

  /** Developers token with permissions to publish package. */
  private token!: string

  /** Published package visibility scope. */
  private scope!: string

  serviceName(): string {
    return 'npm'
  }

  secretValues(): string[] {
    return [this.token!]
  }

  environmentVariables(): Record<string, any> {
    return {}
  }

  readInput(): void {
    this.checkOwnership = getActionBooleanInput('check-ownership', false, 'true')
    this.scope = getActionInput('npm-scope', false, 'public')
    this.token = getActionInput('npm-token', true)

    let packagePath = getActionInput('package-path', false)
    if (!packagePath) this.packagePath = this.filePath({name: 'package.json'}) ?? this.productPath('package.json')
    else this.packagePath = this.productPath(packagePath)

    this.buildCommand = getActionInput('build-command', false, 'gulp compile')
    this.buildPath = this.productPath(getActionInput('build-path', false, 'upload'))
    this.artifactsPath = this.productPath(getActionInput('artifacts-path', false, UPLOAD_FOLDER_PATH), true)
    this.actions = getActionInput('actions', false, 'publish,build')
      .replace(' ', '')
      .split(',') as ('publish' | 'build')[]

    this.artifactsFilter = getActionInput('artifacts-filter', false, '')
      .split(',')
      .filter(filter => filter.length > 0)
  }

  async verifyInput(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    if (!this.packagePath) {
      errorMessage = `'package.json' not found in: ${this.productPath()}.`
      errorSuggestion = 'Ensure that file has been committed (present in product directory for monorepo).'
    } else if (!fs.existsSync(this.packagePath)) {
      errorMessage = `'${path.basename(this.packagePath)}' file not found: ${path.dirname(this.packagePath)}`
      errorSuggestion = 'Make sure that proper relative path has been set (present in product directory for monorepo).'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  // @ts-ignore Async doesn't override properly.
  async updateServiceSettings(): Promise<OperationOutcome> {
    const outcome = await super.updateServiceSettings()

    if (outcome.successful) {
      const npmConfigurationPath = path.join(process.env['HOME']!, '.npmrc')

      this.markChangedSettingsFile(npmConfigurationPath)

      const configuration = `//registry.npmjs.org/:_authToken=${this.token}`
      fs.writeFileSync(npmConfigurationPath, configuration, {encoding: 'utf8'})
    }

    return outcome
  }

  async verifyServiceEnvironment(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    // Check NPM package ownership if required (if publish action listed).
    if (this.checkOwnership && this.actions.includes('publish')) {
      let execOptions = {cwd: path.dirname(this.packagePath)}
      let tokenOwner: string | undefined

      const whoAmIResult = await cliExec({cli: 'npm', commandOrFlags: ['whoami'], execOptions})
      if (whoAmIResult.code === 0) tokenOwner = whoAmIResult.stdout
      else {
        errorMessage = `Unable to get authorised user information: ${whoAmIResult.stderr || whoAmIResult.stdout}`
        errorSuggestion = 'Make sure that used token not revoked and npm CLI has required exec permissions.'
      }

      if (tokenOwner) {
        const ownersResult = await cliExec({
          cli: 'npm',
          commandOrFlags: ['owner', 'ls', this.packageName!],
          execOptions
        })

        if (ownersResult.code === 0) {
          if (!new RegExp(tokenOwner, 'm').test(ownersResult.stdout))
            errorMessage = `${tokenOwner} not listed in ${this.packageName} package owners.`
        } else {
          errorMessage = `Unable to get list of package owners: ${ownersResult.stderr || ownersResult.stdout}`
          errorSuggestion = 'Make sure that used token not revoked and npm CLI has required exec permissions.'
        }
      }
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  async setupServiceEnvironment(): Promise<OperationOutcome> {
    let execOptions = {cwd: path.dirname(this.packagePath)}
    let errorMessage, errorSuggestion: string | undefined

    // Install dependencies.
    const npmInstallResult = await cliExec({cli: 'npm', commandOrFlags: ['ci'], execOptions})
    if (npmInstallResult.code !== 0) {
      errorMessage = `Dependencies installation failed: ${npmInstallResult.stderr || npmInstallResult.stdout}`
      errorSuggestion = 'Ensure that there is no errors in dependency names.'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  async fetchPackageInformation(): Promise<OperationOutcome> {
    const packagePath = this.filePath({name: 'package.json'})
    const packageContent = fs.readFileSync(packagePath!).toString('utf8')
    let errorMessage, errorSuggestion: string | undefined

    const packageJSON: Record<string, any> = JSON.parse(packageContent)

    if (packageJSON) {
      if (!(this.packageName = packageJSON['name'])) errorMessage = `'name' is missing from package config: ${packagePath}`
      if (!errorMessage && !(this.packageVersion = packageJSON['version']))
        errorMessage = `'version' is missing from package config: ${packagePath}`
    } else {
      errorMessage = '\'package.json\' is empty or contains non-UTF8 characters.'
      errorSuggestion = 'Ensure that file not empty and contains only valid characters.'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  override preBuildUserScript(): string {
    return 'pre-npm-build'
  }

  // @ts-ignore Async doesn't override properly.
  async build(): Promise<ationOutcome> {
    if (!this.actions.includes('build')) return {successful: true}

    const commandOrFlags = this.buildCommand.split(' ')
    let execOptions = {cwd: path.dirname(this.packagePath)}
    const cli = commandOrFlags.shift()

    const buildResult = await cliExec({cli: cli!, commandOrFlags, execOptions})

    if (buildResult.code === 0) {
      if (!fs.existsSync(this.artifactsPath!)) fs.mkdirSync(this.artifactsPath!, {recursive: true})
      fse.copySync(this.buildPath!, this.artifactsPath!, { filter: this.artifactsFilterFunction() })
    }

    return {
      successful: buildResult.code === 0,
      errorMessage: buildResult.code !== 0 ? `Package build failed: ${buildResult.stderr || buildResult.stdout}` : undefined
    }
  }

  override prePublishUserScript(): string {
    return 'pre-npm-publish'
  }

  async publish(): Promise<OperationOutcome> {
    if (!this.actions.includes('publish')) return {successful: true}
    let execOptions = {cwd: path.dirname(this.packagePath)}

    const publishResult = await cliExec({cli: 'npm', commandOrFlags: ['publish', '--access', this.scope], execOptions})

    return {
      successful: publishResult.code === 0,
      errorMessage: publishResult.code !== 0 ? `Package publish failed: ${publishResult.stderr || publishResult.stdout}` : undefined
    }
  }
}

/** GitHub action runner entry point. */
async function run(): Promise<void> {
  await NPMService.actionRunner(new NPMService())
}

run()
