import fs from 'fs'
import {getActionInput} from '../../helpers/actions'
import AWSServices from './aws'

/** Class for interaction with Amazon s3 service. */
class AWSS3Service extends AWSServices {
  /** Path to local resources which should be managed. */
  public localPath!: string

  /** s3 bucket path which should be used for files management. */
  public remotePath!: string

  /** Managed files content type. */
  private contentType!: string

  /** Encoding which has been applied on local files. */
  private contentEncoding!: string

  /** Access control list which will manage access to files on s3 bucket. */
  private awsACL!: string

  override readInput() {
    super.readInput()

    // Retrieve user-provided action configuration options.
    this.localPath = this.productPath(getActionInput('local-path', true))
    this.remotePath = getActionInput('remote-path', true)
    this.contentType = getActionInput('content-type', false)
    this.contentEncoding = getActionInput('content-encoding', false)
    this.awsACL = getActionInput('acl', true)
  }

  command(): string {
    return 's3'
  }

  /** At this moment only files copy required. */
  subCommand(): string {
    return 'cp'
  }

  arguments(): string[] {
    let remotePath = this.remotePath
    let cliArguments: string[] = []
    let localPath = this.localPath
    let globMatch

    if (this.contentType) cliArguments.push('--content-type', this.contentType)
    if (this.contentEncoding) cliArguments.push('--content-encoding', this.contentEncoding)
    cliArguments.push('--acl', this.awsACL)

    // Update arguments if local path represents glob.
    if ((globMatch = localPath.match(/(\*.*)/m)) !== null && globMatch.length) {
      localPath = localPath.replace(globMatch[0], '')
      cliArguments.push('--exclude', '"*"', '--include', `${globMatch[1]}`, '--recursive')
    }

    if (AWSS3Service.replaceMetadataRequired(cliArguments)) cliArguments.push('--metadata-directive', 'REPLACE')

    if (!remotePath.startsWith('s3://')) remotePath = 's3://'.concat(remotePath)
    if (!remotePath.endsWith('/')) remotePath = remotePath.concat('/')

    // Verify arguments.
    if (!fs.existsSync(localPath)) throw new Error(`File for upload not found: ${localPath}`)

    return [`${localPath}`, `${remotePath}`].concat(cliArguments)
  }

  /**
   * Check whether `--metadata-directive REPLACE` options should be added to CLI arguments
   * or not.
   *
   * @param {string[]} cliArguments Current list of arguments for CLI call.
   *
   * @return {boolean} `true` in case if metadata should be replaced.
   */
  private static replaceMetadataRequired(cliArguments: string[]): boolean {
    const args = cliArguments.join(' ')

    if (args.match(/(--metadata-directive)/m) !== null)
      return args.match(/(--metadata-directive REPLACE)/m) === null

    const regex = /(--(content-(type|language|encoding|disposition))|cache-control|expires)/m
    return cliArguments.join(' ').match(regex) != null
  }
}

/** GitHub action runner entry point. */
async function run(): Promise<void> {
  await AWSS3Service.actionRunner(new AWSS3Service())
}

run()
