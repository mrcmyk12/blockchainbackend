import * as core from '@actions/core'
import styles from 'ansi-styles'
import path from 'path'
import fs from 'fs'
import {closeIssuesFromChangeLog, emailForUsername, getRepositoryLabels, publishComment, repositoryLabelsSetPlan, setRepositoryLabels} from '../helpers/github'
import {action, checkReleaseProcessStepDone, getActionBooleanInput, getActionInput, releaseProcessMarkStepDone, setupFromReleaseArtifact} from '../helpers/actions'
import {JIRAProjectRelease, OperationOutcome, ReleaseProcessOutcome, RepositoryLabelsSet} from '../helpers/types'
import {fetchReleaseForVersion, jiraProjectKey, repositoryProductName} from '../helpers/jira'
import {notifySlackChannelReleaseCompleted} from '../helpers/slack'
import {productsJSONPath, releaseProcessInformationFilePath} from '../helpers/paths'
import {gitPush, gitTag, setupGit} from '../helpers/git'
import {GITHUB_ACTIONS_PATH} from '../constants'
import {execUserScript} from '../helpers/cli'
import * as log from '../helpers/log'

/** Base class for all package management services. */
export abstract class ServiceBase {
  /** Whether any missing modules / dependencies should be installed to enable service usage. */
  protected shouldSetupServiceEnvironment: boolean = false

  /** Whether service should skip all remaining steps or not. */
  protected shouldSkipRestSteps: boolean = false

  /** Whether service expected to created tag if not done by previous steps. */
  protected shouldCreateTag: boolean = true

  /**
   * List of environment variables which has been set up at the start.
   * This values will be used from within `destroy` function to clean up secrets from runner's
   * environment.
   */
  private readonly envNames: string[]

  /** Pre-processed release information which should be used in release process. */
  protected releaseProcessInformation!: ReleaseProcessOutcome

  /**
   * Path to files which has been modified during service setup.
   * This paths will be used from within `destroy` function to remove those files / restore original.
   * @private
   */
  private readonly changedFiles: string[]

  /** API key which can be used to access JIRA REST API as part of release process. */
  private readonly jiraAPIKey?: string

  /** Version of published / uploaded package. */
  protected packageVersion?: string

  /** Name of package which is published / uploaded to service. */
  protected packageName?: string

  /** Full path to which built artifacts should be moved. */
  protected artifactsPath?: string

  /** List of artifact file names / RegExp which should be used to filter needed artifacts. */
  protected artifactsFilter?: string[]

  /** Full path to folder where artifacts initially should be stored. */
  protected buildPath?: string

  constructor() {
    this.jiraAPIKey = getActionInput('jira-api-key')
    this.changedFiles = []
    this.envNames = []
  }

  /**
   * Name of service which will be used to publish / upload package.
   *
   * @return {string} Short service (CLI) name which will be used for logs output.
   */
  abstract serviceName(): string

  /** Read and store input provided during action configuration. */
  abstract readInput(): void

  /**
   * Retrieve list of values which should be obfuscated in GitHub Actions log.
   *
   * @return {string[]} Values which should be masked in logs.
   */
  abstract secretValues(): string[]

  /**
   * Map of environment key to value which should be associated with it.
   *
   * @return {Record<string,any>} Name of environment variables mapped to their values.
   */
  abstract environmentVariables(): Record<string, any>

  /**
   * Check action configuration input.
   *
   * @return {Promise<OperationOutcome>} Results of asynchronous GitHub Action configuration input verification.
   */
  abstract verifyInput(): Promise<OperationOutcome>

  /**
   * Setup any credentials which is required by service for operation.
   * Good place to setup services which depends from configuration files.
   */
  async updateServiceSettings(): Promise<OperationOutcome> {
    return await setupGit(action.bot.name, emailForUsername(action.bot.username))
  }

  /**
   * Mark specified file as the one, which has been changed during configuration files update.
   *
   * @param {string} filePath Full path to the file, which has been updated.
   */
  markChangedSettingsFile(filePath: string) {
    if (fs.existsSync(filePath)) fs.copyFileSync(filePath, `${filePath}.pnback`)
    this.changedFiles.push(filePath)
  }

  /**
   * Check whether all required components available and can be used or not.
   *
   * @return {Promise<OperationOutcome>} Results of asynchronous service environment checks.
   */
  abstract verifyServiceEnvironment(): Promise<OperationOutcome>

  /**
   * Configure rest of runner environment to use service.
   * This process also may involve missing components / dependencies installation.
   *
   * @return {Promise<OperationOutcome>} Asynchronous results of missing service / modules / dependencies installation.
   */
  abstract setupServiceEnvironment(): Promise<OperationOutcome>

  /** Clean up any resources / changes done in `setupServiceEnvironment`. */
  async cleanupServiceEnvironment(): Promise<void> {
  }

  /**
   * Use action input to set env variables which can be used by some CLI.
   *
   * @param {Record<string,any>} variables Map of environment variable name to value which should be assigned to it.
   * @private
   */
  private setupEnvironmentVariables(variables: Record<string, any>) {
    Object.keys(variables).forEach(key => {
      this.envNames.push(key)
      core.exportVariable(key, variables[key])
    })
  }

  /**
   * Load information about package from any available resources.
   *
   * @return {Promise<OperationOutcome>} Results of asynchronous package information retrieve operation.
   */
  abstract fetchPackageInformation(): Promise<OperationOutcome>

  /**
   * Perform runner and service environment setup.
   *
   * @return {Promise<OperationOutcome>} Results of asynchronous runner setup for deployment with current service.
   */
  private async setup(): Promise<OperationOutcome> {
    let outcome: OperationOutcome

    log.info(`Verify GitHub Action input for ${styles.bold.open}${this.serviceName()}${styles.bold.close}.`)
    outcome = await this.verifyInput()
    if (outcome.successful && !action.github.ghToken && !action.github.token){
      outcome.successful = false
      outcome.errorMessage = 'GitHub Personal Access Token,'
      outcome.errorSuggestion = 'Ensure that at leas one of \'github-token\' or \'token\' is set in workflow.'
    }
    if (outcome.successful) log.success('GitHub Action inputs valid.')

    // Fetch release artifacts only for PR
    if (outcome.successful && !action.isRegularPush && action.issue.type === 'pull-request') {
      // Fetching release process information if required.
      if (outcome.successful && !fs.existsSync(releaseProcessInformationFilePath())) {
        log.info(`Fetch release process information file for issue #${styles.bold.open}${action.issue.number}${styles.bold.close}.`)
        const downloadOutcome = await setupFromReleaseArtifact(action.issue.number)
        outcome = downloadOutcome

        if (outcome.successful) {
          this.releaseProcessInformation = downloadOutcome
          log.success('Release process information retrieved.')
        }
      } else this.releaseProcessInformation = JSON.parse(fs.readFileSync(releaseProcessInformationFilePath()).toString('utf8'))

      // Update repository labels if required.
      if (outcome.successful) outcome = await this.setupLabels()
    }

    if (outcome.successful) {
      log.info('Get package information')
      outcome = await this.fetchPackageInformation()

      if (outcome.successful) {
        if (this.packageVersion)
          log.success(`${styles.bold.open}${this.packageName} ${this.packageVersion}${styles.bold.close} package detected`)
        else if (this.packageName)
          log.success(`${styles.bold.open}${this.packageName}${styles.bold.close} package detected`)
        else log.success(`Package doesn't rely on package name / version.`)
      }
    }

    if (outcome.successful) {
      log.info(`Update ${styles.bold.open}${this.serviceName()}${styles.bold.close} configuration files.`)
      outcome = await this.updateServiceSettings()
      if (outcome.successful) log.success(`${this.serviceName()} configuration files updated.`)
    }

    if (outcome.successful) {
      log.info(`Verify ${styles.bold.open}${this.serviceName()}${styles.bold.close} environment`)
      outcome = await this.verifyServiceEnvironment()
      if (outcome.successful)
        log.success(`${styles.bold.open}${this.serviceName()}${styles.bold.close} can be used.`)
    }

    if (outcome.successful && this.shouldSetupServiceEnvironment) {
      log.info(`Setup ${styles.bold.open}${this.serviceName()}${styles.bold.close} environment`)
      outcome = await this.setupServiceEnvironment()
      if (outcome.successful)
        log.success(`${styles.bold.open}${this.serviceName()}${styles.bold.close} environment setup completed.`)
    }

    return outcome
  }

  /**
   * Verify that repository has required set of labels, so they can be set in case if any issues addressed.
   *
   * @return {Promise<OperationOutcome>} Asynchronous results of labels setup.
   * @private
   */
  private async setupLabels(): Promise<OperationOutcome> {
    let outcome: OperationOutcome | undefined
    let {owner, repo} = action.repository

    log.info(`Checking ${styles.bold.open}${this.slug()}${styles.bold.close} issue / PR labels`)
    const repositoryLabels = await getRepositoryLabels(owner, repo)
    outcome = repositoryLabels

    if (repositoryLabels.successful) {
      const labelsSetPath = this.productPath(`${GITHUB_ACTIONS_PATH}/resources/github/labels.json`, true)
      const labels = JSON.parse(fs.readFileSync(labelsSetPath).toString('utf8')) as RepositoryLabelsSet

      const plan = repositoryLabelsSetPlan(labels, repositoryLabels.labels)

      if (plan.add.length || plan.remove.length) {
        if (plan.add.length)
          log.info(
            `Adding ${styles.bold.open}${plan.add.length}${
              styles.bold.close
            } labels to ${styles.bold.open}${this.slug()}${
              styles.bold.close
            } repository labels list`
          )

        if (plan.remove.length)
          log.info(
            `Removing ${styles.bold.open}${
              plan.remove.length == repositoryLabels.labels.length ||
              plan.remove.length > 5 ? 'all' : plan.remove.length
            }${styles.bold.close} labels from ${
              styles.bold.open
            }${this.slug()}${styles.bold.close} repository labels list`
          )

        outcome = await setRepositoryLabels(owner, repo, plan.add, plan.remove)
        // outcome = await setRepositoryLabels(plan.add, plan.remove)
      } else log.success('All required issue / PR labels is present.')
    }

    return outcome
  }

  /**
   * User script which should be executed before package build stage.
   *
   * @return {string} Name of script to execute before service 'build' step.
   */
  preBuildUserScript(): string {
    return 'pre-build'
  }

  /**
   * Build artifacts and place them to appropriate location for upload to service.
   *
   * @return {Promise<OperationOutcome>} Results of asynchronous project artifacts build process.
   */
  async build(): Promise<OperationOutcome> {
    return {successful: true}
  }

  /**
   * User script which should be executed before package publish stage.
   *
   * @return {string} Name of script to execute before service 'publish' step.
   */
  prePublishUserScript(): string {
    return 'pre-publish'
  }

  /** Publish artifacts to the service. */
  abstract publish(): Promise<OperationOutcome>

  /**
   * Perform build and publish / upload.
   *
   * @return {Promise<OperationOutcome>} Run base service actions to build and deploy package / library.
   */
  async run(): Promise<OperationOutcome> {
    // Try call pre-build scripts for service (to run user-defined logic).
    let outcome = await execUserScript(this.preBuildUserScript())

    // Keep service artifacts building and publish.
    if (outcome.successful) outcome = await this.build()
    if (!outcome.successful) return outcome

    // Skip further steps if required.
    if (this.shouldSkipRestSteps)  {
      await this.destroy()
      return {successful: true}
    }

    outcome = await execUserScript(this.prePublishUserScript())

    return outcome.successful ? await this.publish() : outcome
  }

  /**
   * Retrieve GitHub slug for repo on which action is running.
   *
   * @return {string} GitHub slug name for repository handled by runner.
   */
  slug(): string {
    return process.env['GITHUB_REPOSITORY']!
  }

  /**
   * Full path to location where repository code has been checked out.
   *
   * @param {string|undefined} append Path which should be appended to project path.
   * @param {boolean} base Whether base (non-monorepo) project path should be used or not.
   *
   * @return {string} Full path to folder with project code or sub-folder if `append` is passed.
   */
  productPath(append?: string, base: boolean = false): string {
    let workspace = base ? action.rootWorkingDirectory : action.productWorkingDirectory
    return !append ? workspace : path.join(workspace, append)
  }

  /**
   * Find and return full path for specified file.
   *
   * @param {name:string|undefined,startsWith:string|undefined,endsWith:string|undefined} searchOption Searched file
   * name match options.
   * @param {string|undefined} relativePath Provided relative path for file which should be found.
   */
  filePath(searchOption: { name?: string; startsWith?: string; endsWith?: string }, relativePath?: string): string | undefined {
    if (Object.keys(searchOption).length === 0) return undefined

    let searchedFilePath = relativePath

    if (!searchedFilePath) {
      // Get list of files in target project directory (root for non-monorepo).
      const filesList = fs.readdirSync(this.productPath())

      for (let fileName of filesList) {
        if (searchOption.name && fileName === searchOption.name) searchedFilePath = fileName
        else if (searchOption.startsWith && fileName.startsWith(searchOption.startsWith)) searchedFilePath = fileName
        else if (searchOption.endsWith && fileName.endsWith(searchOption.endsWith)) searchedFilePath = fileName

        if (searchedFilePath) break
      }
    } else if (!fs.existsSync(this.productPath(searchedFilePath))) searchedFilePath = undefined

    // Compose full path to searched file (taking target project directory as base).
    return searchedFilePath ? this.productPath(searchedFilePath) : undefined
  }

  /**
   * Service artifact copy filter function.
   *
   * @return {(src: string) => boolean} Function which can be used to filter unwanted files from artifacts folder.
   * @protected
   */
  protected artifactsFilterFunction(): (src: string) => boolean {
    return (src: string): boolean => {
      if (this.artifactsFilter && this.artifactsFilter.length) {
        let shouldCopy = false

        for (let fileFilter of this.artifactsFilter) {
          if (fileFilter.includes('.*') || fileFilter.includes('.+') || fileFilter.includes('$'))
            shouldCopy = (new RegExp(fileFilter, 'g')).test(src)
          else shouldCopy = src.endsWith(fileFilter)

          if (shouldCopy) break
        }

        return shouldCopy
      } else return true
    }
  }

  /** Clean up after service script. */
  async destroy() {
    for (let variable of this.envNames) core.exportVariable(variable, '')
    for (let filePath of this.changedFiles) {
      if (fs.existsSync(`${filePath}.pnback`)) fs.renameSync(`${filePath}.pnback`, filePath)
      else if (fs.existsSync(filePath)) fs.unlinkSync(filePath)
    }
    await this.cleanupServiceEnvironment()
  }

  /**
   * Run service within GitHub Action run function.
   *
   * @param {ServiceBase} service Service for which all setups should be done and used for current project
   * deployment to target service.
   */
  static async actionRunner(service: ServiceBase): Promise<void> {
    let outcome: OperationOutcome

    log.info(`Distribute package using ${styles.bold.open}${service.serviceName()}${styles.bold.close}`)

    try {
      core.startGroup(`Read ${styles.bold.open}${service.serviceName()}${styles.bold.close} configuration from GitHub Action workflow`)
      // Initial service setup.
      service.readInput()
      const isLastService = getActionBooleanInput('last-service', false, 'false')

      ServiceBase.protectSecrets(service.secretValues())
      service.setupEnvironmentVariables(service.environmentVariables())
      core.endGroup()

      // Skip further steps if required.
      if (service.shouldSkipRestSteps) return

      core.startGroup(`Setting up runner for ${styles.bold.open}${service.serviceName()}${styles.bold.close} usage`)
      outcome = await service.setup()
      if (outcome.successful) core.endGroup()

      // Skip further steps if required.
      if (service.shouldSkipRestSteps) {
        await service.destroy()
        return
      }

      if (outcome.successful && !action.isRegularPush) {
        core.startGroup('Distributing package')

        if (service.releaseProcessInformation.changelog) {
          const {version} = service.releaseProcessInformation.changelog

          if (service.shouldCreateTag && !checkReleaseProcessStepDone('create-tag', service.releaseProcessInformation)) {
            log.info(`Creating ${styles.bold.open}${version}${styles.bold.close} release tag`)

            outcome = await gitTag(version!)

            // Push new tag to remote.
            if (outcome.successful) outcome = await gitPush(action.rootWorkingDirectory, version)
            if (outcome.successful) releaseProcessMarkStepDone('create-tag', service.releaseProcessInformation)
          } else if (service.shouldCreateTag) log.success(`${styles.bold.open}${version}${styles.bold.close} tag already exists.`)
          else log.info(`${service.serviceName()} doesn't require tag.`)
        }

        if (!checkReleaseProcessStepDone(service.serviceName(), service.releaseProcessInformation)) {
          outcome = await service.run()

          if (outcome.successful) releaseProcessMarkStepDone(service.serviceName(), service.releaseProcessInformation)
        } else log.success(`Packages already released using ${styles.bold.open}${service.serviceName()}${styles.bold.close}.`)
        if (outcome.successful) core.endGroup()
      } else if (outcome.successful) {
        core.startGroup('Distributing package')
        outcome = await service.run()
      }

      // Skip further steps if required.
      if (service.shouldSkipRestSteps)  {
        await service.destroy()
        return
      }

      // Close any addressed issues and add corresponding labels.
      if (outcome.successful && !action.isRegularPush && isLastService && service.releaseProcessInformation.changelog) {
        let {changelog} = service.releaseProcessInformation
        const addressedIssuesCount = changelog.entries.filter(entry => entry.addressedIssues && entry.addressedIssues.length).length

        if (addressedIssuesCount > 0) {
          core.startGroup('Closing addressed issues')

          if (!checkReleaseProcessStepDone('close-issues', service.releaseProcessInformation)) {
            await closeIssuesFromChangeLog(action.repository.owner, action.repository.repo, service.releaseProcessInformation.changelog)
            releaseProcessMarkStepDone('close-issues', service.releaseProcessInformation)
          } else log.success(`${styles.bold.open}${addressedIssuesCount}${styles.bold.close} issues already closed.`)

          core.endGroup()
        }

        core.startGroup('Notify release completion')

        // Try publish release completion information to PR.
        const publishOutcome = await publishComment(
          action.repository.owner,
          action.repository.repo,
          action.issue.number,
          'ðŸš€ Release successfully completed ðŸš€'
        )
        if (publishOutcome.successful)
          log.success(`Notified on ${styles.bold.open}${
            action.issue.number
          }${styles.bold.close} PR about release completion.`)
        else log.warning(`Unable to leave comment on ${styles.bold.open}${
          action.issue.number
        }${styles.bold.close} PR: ${publishOutcome.errorMessage}`)

        let jiraReleaseVersion: JIRAProjectRelease | undefined = undefined
        if (changelog?.version && service.jiraAPIKey && service.jiraAPIKey.length > 0) {
          const projectKey = jiraProjectKey()

          if (projectKey) {
            jiraReleaseVersion = await fetchReleaseForVersion(changelog.version, service.jiraAPIKey)
            let product = repositoryProductName()

            if (productsJSONPath() && service.releaseProcessInformation.product && service.releaseProcessInformation.product.name)
              product = service.releaseProcessInformation.product.name
            if (jiraReleaseVersion) log.success(`${styles.bold.open}${product}${styles.bold.close} JIRA release retrieved.`)
            else log.warning(`${styles.bold.open}${product}${styles.bold.close} doesn't have JIRA release.`)
          } else log.success(`${styles.bold.open}${action.repository.repo}${styles.bold.close} doesn't require report to Slack channel.`)
        }

        outcome = await notifySlackChannelReleaseCompleted(service.releaseProcessInformation, jiraReleaseVersion)
        core.endGroup()
      }

      if (outcome.errorSuggestion) log.warning(outcome.errorSuggestion)
      if (outcome.errorMessage) core.setFailed(outcome.errorMessage)
      if (!outcome.successful) core.endGroup()
    } catch (error) {
      core.setFailed(error.message)
    }

    // Clean up resources which has been used with `setup` function call.
    await service.destroy()
    core.endGroup()
  }

  /**
   * Hide all secrets from logs.
   *
   * @param {string[]} secrets List of values which should be obfuscated in GitHub Action logs.
   * @private
   */
  private static protectSecrets(secrets: string[]) {
    for (let value of secrets) core.setSecret(value)
  }
}
