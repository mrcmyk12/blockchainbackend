import * as http from '@actions/http-client'
// @ts-ignore
import decompress from 'decompress'
import fse from 'fs-extra'
import path from 'path'
import fs from 'fs'
import {checkJavaVersion, javaHome} from '../../installers/install-java'
import {GITHUB_ACTIONS_PATH, UPLOAD_FOLDER_PATH} from '../../constants'
import {getPublicIPAddress} from '../../helpers/network'
import {getActionInput} from '../../helpers/actions'
import {OperationOutcome} from '../../helpers/types'
import {decryptFile} from '../../helpers/openssl'
import {cliExec} from '../../helpers/cli'
import * as log from '../../helpers/log'
import * as Service from '../service'

/** Profile which is used by Nexus Repository to prepare release repository. */
const RELEASE_PROFILE_NAME = 'com.pubnub'

/** How many times script should retry check on whether staging repository finally closed or not. */
const CLOSE_CHECK_RETRY_COUNT = 60

/** Delay between staging 'closed' status checks. */
const CLOSE_CHECK_RETRY_DELAY = 30

/** List of Maven plugins currently supported. */
type SupportedMavenPlugins = 'gradle-nexus-plugin' | 'gradle-maven-publish-plugin'

/** Base object which represent Sonatype REST API calls response. */
type SonatypeRESTAPIResponse = {
  /** Whether REST API call returned with status code < 400 or not. */
  successful: boolean

  /** Service response (if not error). */
  data?: any

  /** Service error message (if failed). */
  errorMessage?: string
}

/** Staging repository information representation object. */
type StagingRepository = {
  profileName: string
  repositoryId?: string
  type: 'open' | 'closed'
  ipAddress: string
  updatedTimestamp?: number
  transitioning: boolean
}

/** Current staging repository information representation object. */
type StagingRepositoryFetch = SonatypeRESTAPIResponse & {
  repository?: StagingRepository
}

/** Close staging repository information representation object. */
type StagingRepositoryClose = SonatypeRESTAPIResponse

/** Maven service package handler. */
class MavenService extends Service.ServiceBase {
  /** HTTP client to access Nexus REST API. */
  private httpClient: http.HttpClient

  /** GPG key passphrase. */
  private keyPassphrase!: string

  /** Plugin which should be used and configured for project release. */
  private mavenPlugin!: SupportedMavenPlugins

  /** Short GPG key identifier. */
  private keyShortId!: string

  /** Sonatype Nexus repository account username which will be used with Nexus REST API. */
  private username!: string

  /** Sonatype Nexus repository account password which will be used with Nexus REST API. */
  private password!: string

  /** Real GPG key name (with which it has been created). */
  private keyName!: string

  /** Full path to GPG key which should be used during publish to Sonatype Nexus repository. */
  private keyPath!: string

  /** Full GPG key identifier. */
  private keyId!: string

  constructor() {
    super()

    this.httpClient = new http.HttpClient('deploy-http-client', [], {
      headers: {'Content-Type': 'application/json', Accept: 'application/json'}
    })

    // JCE policy should be installed.
    this.shouldSetupServiceEnvironment = true
  }

  serviceName(): string {
    return 'maven'
  }

  secretValues(): string[] {
    return [
      this.username,
      this.password,
      this.keyId,
      this.keyName,
      this.keyPassphrase
    ]
  }

  environmentVariables(): Record<string, any> {
    return {}
  }

  readInput(): void {
    this.username = getActionInput('nexus-username', true)
    this.password = getActionInput('nexus-password', true)
    this.keyId = getActionInput('gpg-key-id', true)
    this.keyName = getActionInput('gpg-key-name', true)
    this.keyPassphrase = getActionInput('gpg-key-passphrase', true)
    this.buildPath = this.productPath(getActionInput('build-path', false, 'build/libs'))
    this.artifactsPath = this.productPath(getActionInput('artifacts-path', false, UPLOAD_FOLDER_PATH), true)
    this.keyShortId = this.keyId.substring(this.keyId.length - 8)
    this.keyPath = this.productPath(`${GITHUB_ACTIONS_PATH}/resources/maven/${this.keyShortId}.gpg`, true)
    this.mavenPlugin = getActionInput('maven-plugin', false) as SupportedMavenPlugins

    this.artifactsFilter = getActionInput('artifacts-filter', false, '')
      .split(',')
      .filter(filter => filter.length > 0)
  }

  async verifyInput(): Promise<OperationOutcome> {
    const settingsGradleFilePath = this.productPath('settings.gradle')
    const buildGradleFilePath = this.productPath('build.gradle')
    let errorMessage, errorSuggestion: string | undefined
    const encryptedFilePath = `${this.keyPath}.enc`

    if (!fs.existsSync(encryptedFilePath)) {
      errorMessage = `Unable to locate GPG key with identifier: ${this.keyShortId}`
      errorSuggestion = 'Ensure that key file committed and proper name / identifier has been specified.'
    } else {
      const decryptResult = await decryptFile(encryptedFilePath, this.keyPath, this.keyPassphrase, this.keyId)

      if (!decryptResult.successful) {
        errorMessage = decryptResult.errorMessage
        errorSuggestion = decryptResult.errorSuggestion
      }
    }

    if (!errorMessage && !fs.existsSync(buildGradleFilePath)) {
      errorMessage = `'build.gradle' not found in: ${this.productPath()}`
      errorSuggestion = 'Ensure that target project directory contains \'build.gradle\' file.'
    }

    if (!errorMessage && !fs.existsSync(settingsGradleFilePath)) {
      errorMessage = `'settings.gradle' not found in: ${this.productPath()}`
      errorSuggestion = 'Ensure that target project directory contains \'settings.gradle\' file.'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  // @ts-ignore Async doesn't override properly.
  async updateServiceSettings(): Promise<OperationOutcome> {
    const outcome = await super.updateServiceSettings()

    if (outcome.successful) {
      const gradlePropertiesPath = `${process.env['HOME']}/.gradle/gradle.properties`
      const mavenConfigurationPath = `${process.env['HOME']}/.m2/settings.xml`

      this.markChangedSettingsFile(mavenConfigurationPath)
      this.markChangedSettingsFile(gradlePropertiesPath)

      const mavenConfiguration = `<settings>
  <servers>
    <server>
      <id>sonatype-nexus-snapshots</id>
      <username>${this.username}</username>
      <password>${this.password}</password>
    </server>
    <server>
      <id>sonatype-nexus-staging</id>
      <username>${this.username}</username>
      <password>${this.password}</password>
    </server>
  </servers>
  <profiles>
    <profile>
      <id>gpg</id>
      <properties>
        <gpg.keyname>${this.keyName}</gpg.keyname>
        <gpg.passphrase>${this.keyPassphrase}</gpg.passphrase>
      </properties>
    </profile>
  </profiles>
</settings>`

      const gradleProperties = `signing.keyId=${this.keyShortId}
signing.secretKeyRingFile=${this.keyPath}
signing.password=${this.keyPassphrase}
nexusUsername=${this.username}
nexusPassword=${this.password}
mavenCentralUsername=${this.username}
mavenCentralPassword=${this.password}`

      if (!fs.existsSync(path.dirname(gradlePropertiesPath)))
        fs.mkdirSync(path.dirname(gradlePropertiesPath), {recursive: true})

      if (!fs.existsSync(path.dirname(mavenConfigurationPath)))
        fs.mkdirSync(path.dirname(mavenConfigurationPath), {recursive: true})

      // Update Maven settings before publish.
      fs.writeFileSync(mavenConfigurationPath, mavenConfiguration)

      // Update Gradle settings before publish.
      fs.writeFileSync(gradlePropertiesPath, gradleProperties)
    }

    return outcome
  }

  async verifyServiceEnvironment(): Promise<OperationOutcome> {
    const javaCheckResult = checkJavaVersion(8)

    return {
      successful: !javaCheckResult.errorMessage && javaCheckResult.available,
      errorMessage: javaCheckResult.errorMessage,
      errorSuggestion: javaCheckResult.errorSuggestion
    }
  }

  async setupServiceEnvironment(): Promise<OperationOutcome> {
    const securityPath = `${javaHome(8)}/lib/security`
    let errorMessage, errorSuggestion: string | undefined

    // Check whether security policy already installed or not.
    if (!fs.existsSync(securityPath)) {
      fs.mkdirSync(securityPath, {recursive: true})

      try {
        const mavenResource = this.productPath(`${GITHUB_ACTIONS_PATH}/resources/maven`, true)

        await decompress(`${mavenResource}/jce_policy-8.tar.gz`, mavenResource)
        fse.copySync(`${mavenResource}/UnlimitedJCEPolicyJDK8`, securityPath)
      } catch (error) {
        errorMessage = `Decompression failed: ${error.message}`
        errorSuggestion = 'Ensure that file has been compressed using GZIP.'
      }
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  // @ts-ignore Async doesn't override properly.
  async cleanupServiceEnvironment(): Promise<void> {
    await super.cleanupServiceEnvironment()

    // Clean up sensitive information from container.
    fs.unlinkSync(this.keyPath)
  }

  async fetchPackageInformation(): Promise<OperationOutcome> {
    const settingsGradleFilePath = this.productPath('settings.gradle')
    let buildGradleFilePath = this.productPath('build.gradle')
    let errorMessage, errorSuggestion: string | undefined
    let matchedVersion: RegExpMatchArray | null

    const gradleContent = fs.readFileSync(buildGradleFilePath, {encoding: 'utf8'})
    matchedVersion = gradleContent.match(/^version\s?=\s?'(v?(\d+\.?){2,}([a-zA-Z0-9-]+(\.?\d+)?)?)'$/m)
    if (!matchedVersion || matchedVersion.length < 1) {
      matchedVersion = gradleContent.match(/^versionName\s?=\s?'(v?(\d+\.?){2,}([a-zA-Z0-9-]+(\.?\d+)?)?)'$/m)
    }

    if (matchedVersion && matchedVersion.length > 1) this.packageVersion = matchedVersion[1]

    if (!errorMessage) {
      const gradleContent = fs.readFileSync(settingsGradleFilePath, {encoding: 'utf8'})
      const matchedName = gradleContent.match(/^rootProject\.name\s?=\s?['"]([a-zA-Z0-9\s.-]*)['"]$/m)

      if (!matchedName || matchedName.length < 1) {
        errorMessage = `'rootProject.name' is missing from settings.gradle: ${settingsGradleFilePath}`
        errorSuggestion = 'Ensure that \'settings.gradle\' file not corrupted.'
      } else this.packageName = matchedName[1]
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  override preBuildUserScript(): string {
    return 'pre-maven-build'
  }

  // @ts-ignore Async doesn't override properly.
  async build(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    if (this.mavenPlugin === 'gradle-maven-publish-plugin') {
      return { successful: true }
    }

    const buildResult = await cliExec({cli: process.env['SHELL'] || 'bash', commandOrFlags: ['gradlew', 'shadowJar']})

    if (buildResult.code === 0) {
      if (fs.existsSync(this.buildPath!) && fs.readdirSync(this.buildPath!).length > 0)
        fse.copySync(this.buildPath!, this.artifactsPath!, { filter: this.artifactsFilterFunction() })
      else {
        errorMessage = 'Library build failed.'
        errorSuggestion = 'Check \'build.gradle\' and verify library compilation configured correctly.'
      }
    } else {
      errorMessage = `Library build failed: ${buildResult.stderr || buildResult.stdout}`
      errorSuggestion = 'Review error message and fix mentioned issues.'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  override prePublishUserScript(): string {
    return 'pre-maven-publish'
  }

  async publish(): Promise<OperationOutcome> {
    let stagingRepository: StagingRepositoryFetch | undefined
    let errorMessage, errorSuggestion: string | undefined
    let commandOrFlags: string[] = ['gradlew', 'shadowJar', 'upload']

    if (this.mavenPlugin === 'gradle-maven-publish-plugin') {
      commandOrFlags = ['gradlew', 'publish', '--no-daemon', '--no-parallel']
    }

    log.info(`Creating staging repository and upload ${this.packageName} ${this.packageVersion} library.`)
    let uploadResult = await cliExec({ cli: process.env['SHELL'] || 'bash', commandOrFlags })

    if (this.mavenPlugin === 'gradle-maven-publish-plugin' && uploadResult.code === 0) {
      uploadResult = await cliExec({ cli: process.env['SHELL'] || 'bash', commandOrFlags: ['gradlew', 'closeAndReleaseRepository'] })
    }

    if (this.mavenPlugin !== 'gradle-maven-publish-plugin' && uploadResult.code === 0) {
      stagingRepository = await this.fetchCurrentStagingRepository()

      if (!stagingRepository.repository) {
        errorMessage = stagingRepository.errorMessage
        errorSuggestion = 'Looks like Nexus Repository experience some latencies. Try again later.'
      }
    } else if (uploadResult.code !== 0) {
      errorMessage = `Unable to publish library: ${uploadResult.stderr || uploadResult.stderr}`
      errorSuggestion = 'Ensure that all credentials is set properly and library is buildable'
    }

    const {repository} = stagingRepository ?? {}
    if (!errorMessage && repository && repository.repositoryId) {
      const closeResult = await this.closeCurrentStagingRepository(repository.repositoryId)

      if (!closeResult.successful) {
        errorMessage = closeResult.errorMessage
        errorSuggestion = 'Looks like Nexus Repository experience some latencies oe validation rules failed.'
      } else {
        const promoteResult = await this.promoteStagingRepository(repository.repositoryId)

        if (!promoteResult.successful) {
          errorMessage = promoteResult.errorMessage
          errorSuggestion = 'Please check http://oss.sonatype.org to get more information on last build.'
        }
      }
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  /**
   * Filter out active staging repositories to find the one which has been created during deployment process.
   * @private
   *
   * @return {Promise<StagingRepositoryFetch>} Asynchronously retrieved current staging repository information.
   */
  private async fetchCurrentStagingRepository(): Promise<StagingRepositoryFetch> {
    let currentRepository: StagingRepository | undefined
    let errorMessage: string | undefined

    log.info('Waiting for staging repository creation (10 seconds).')

    // Give Nexus Repository some time to create staging repository.
    await new Promise(resolve => setTimeout(resolve, 10000))

    log.info('Fetching staging repositories.')

    // After shadowJar upload Nexus Repository expected to create release repository.
    const response = await this.httpClient.get(
      'https://oss.sonatype.org/service/local/staging/profile_repositories',
      {Authorization: `Basic ${this.nexusRESTAPIToken()}`}
    )

    const responseBody: { data?: StagingRepository[] } = JSON.parse(await response.readBody())

    if ((response.message.statusCode ?? 500) >= 400) errorMessage = 'Not authorized / endpoint not implemented'
    else if (!responseBody || !responseBody.data) errorMessage = 'Malformed REST API response'
    else {
      let repositories: StagingRepository[] = responseBody.data
      const externalIpAddress = await getPublicIPAddress()

      if (repositories.length === 0) errorMessage = 'Unable to find any staging repositories.'
      else {
        repositories = repositories.filter(
          repository =>
            repository.profileName === RELEASE_PROFILE_NAME &&
            repository.repositoryId &&
            repository.ipAddress === externalIpAddress &&
            repository.updatedTimestamp &&
            !repository.transitioning
        )

        if (repositories.length > 0) {
          // Allowing only 5 minute old staging repositories.
          const releaseTimeframeStart = new Date().getTime() - 300 * 1000
          repositories = repositories.filter(
            repository =>
              repository.updatedTimestamp &&
              repository.updatedTimestamp >= releaseTimeframeStart
          )

          if (repositories.length) currentRepository = repositories[0]
          else errorMessage = `'${this.packageName}' staging repository created more than 5 minutes ago.`
        } else errorMessage = 'Unable to fine staging repository which has been created recently.'
      }
    }

    return {successful: currentRepository !== undefined, repository: currentRepository, errorMessage}
  }

  /** Trigger staging repository close (commit changes) */
  private async closeCurrentStagingRepository(
    repositoryId: string,
    retryCount: number = CLOSE_CHECK_RETRY_COUNT
  ): Promise<StagingRepositoryClose> {
    let errorMessage: string | undefined
    // Staging repository close payload.
    const payload = {
      data: {
        stagedRepositoryIds: [repositoryId],
        description: `Prepared for ${this.packageName} ${this.packageVersion} release`
      }
    }

    log.info(`Changing '${this.packageName}' staging repository status to 'closed'`)

    // Trigger staging repository close (commit changes) before propagation release.
    const closeResponse = await this.httpClient.post(
      'https://oss.sonatype.org/service/local/staging/bulk/close',
      JSON.stringify(payload),
      {Authorization: `Basic ${this.nexusRESTAPIToken()}`}
    )

    if ((closeResponse.message.statusCode ?? 500) >= 400) errorMessage = 'Not authorized / endpoint not implemented'
    else {
      const callRESTAPI = async (): Promise<{ message: { statusCode?: number }, readBody(): Promise<string> }> =>
        this.httpClient.get(
          `https://oss.sonatype.org/service/local/staging/repository/${repositoryId}`,
          {Authorization: `Basic ${this.nexusRESTAPIToken()}`}
        )

      for (let currentRetryAttempt = 0; currentRetryAttempt < retryCount; currentRetryAttempt++) {
        log.info(`Checking '${this.packageName}' staging repository status is 'closed' (${currentRetryAttempt + 1} / ${retryCount})`)

        const checkResults = await callRESTAPI()

        if ((checkResults.message.statusCode ?? 500) === 200) {
          const repository: StagingRepository = JSON.parse(await checkResults.readBody())

          if (!repository.transitioning) {
            if (repository.type !== 'closed') errorMessage = 'Unable to close staging repository.'
            break
          }

          // Give Nexus Repository more time to process staging repository close request.
          await new Promise(resolve => setTimeout(resolve, CLOSE_CHECK_RETRY_DELAY * 1000)
          )
        }
      }
    }

    return {successful: !errorMessage, errorMessage}
  }

  private async promoteStagingRepository(repositoryId: string): Promise<SonatypeRESTAPIResponse> {
    let errorMessage: string | undefined
    // Staging repository promote payload.
    const payload = {
      data: {
        autoDropAfterRelease: true,
        stagedRepositoryIds: [repositoryId],
        description: `Release ${this.packageName} ${this.packageVersion}`
      }
    }

    log.info(`Promoting '${this.packageName}' staging repository as ${this.packageVersion} library version`)

    // Complete staging repository promotion to release.
    const promoteResponse = await this.httpClient.post(
      'https://oss.sonatype.org/service/local/staging/bulk/promote',
      JSON.stringify(payload),
      {Authorization: `Basic ${this.nexusRESTAPIToken()}`}
    )

    if ((promoteResponse.message.statusCode ?? 500) >= 400) errorMessage = 'Not authorized / endpoint not implemented'

    return {successful: !errorMessage, errorMessage}
  }

  /** Compose Sonatype REST API access token from provided GitHub Action input. */
  private nexusRESTAPIToken(): string {
    return Buffer.from(`${this.username}:${this.password}`).toString('base64')
  }
}

/** GitHub action runner entry point. */
async function run(): Promise<void> {
  await MavenService.actionRunner(new MavenService())
}

run()
