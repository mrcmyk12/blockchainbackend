import path from 'path'
import fs from 'fs'
import {checkCocoaPodsVersion, installCocoaPods} from '../../installers/install-cocoapods'
import {getActionInput, getActionBooleanInput} from '../../helpers/actions'
import {OperationOutcome} from '../../helpers/types'
import {cliExec} from '../../helpers/cli'
import * as Service from '../service'

/** Pod service package handler. */
class PodService extends Service.ServiceBase {
  /** Whether CocoaPods library should be installed / updated or not. */
  private shouldInstallCocoaPods = false
  private shouldUpdateCocoaPods = false

  /** Whether CocoaPods library ownership should be checked before publish or not. */
  private checkOwnership!: boolean

  /** Whether CocoaPod warnings shouldn't be treated as errors and cancel publish. */
  private allowWarnings!: boolean

  /**
   * Full path to location of `.podspec` file. Service will try to locate it if not passed in GitHub Action
   * configuration.
   * @private
   */
  private specPath?: string

  /** CocoaPods trunk API access token with permissions to publish target library. */
  private token!: string

  serviceName(): string {
    return 'pod'
  }

  secretValues(): string[] {
    return [this.token]
  }

  environmentVariables(): Record<string, any> {
    return {COCOAPODS_TRUNK_TOKEN: this.token}
  }

  readInput(): void {
    this.checkOwnership = getActionBooleanInput('check-ownership', false)
    this.allowWarnings = getActionBooleanInput('allow-warnings', false)
    this.token = getActionInput('cocoapods-token', true)
    this.specPath = this.filePath({endsWith: '.podspec'}, getActionInput('podspec-path', false)
    )
  }

  async verifyInput(): Promise<OperationOutcome> {
    let errorSuggestion: string | undefined
    let errorMessage: string | undefined

    if (!this.specPath) errorMessage = 'Podspec file not set.'
    else if (!fs.existsSync(this.specPath)) {
      errorMessage = `'${path.basename(this.specPath)}' file not found: ${path.dirname(this.specPath)}`
      errorSuggestion = 'Make sure that proper relative path has been set (present in product directory for monorepo).'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  async verifyServiceEnvironment(): Promise<OperationOutcome> {
    // Check whether minimum required CocoaPods version installed.
    const cocoaPodsCheckResult = await checkCocoaPodsVersion(1, 10, 1)
    this.shouldSetupServiceEnvironment = !cocoaPodsCheckResult.installed || !cocoaPodsCheckResult.match
    this.shouldUpdateCocoaPods = cocoaPodsCheckResult.installed && !cocoaPodsCheckResult.match
    this.shouldInstallCocoaPods = !cocoaPodsCheckResult.installed

    return {successful: true}
  }

  async setupServiceEnvironment(): Promise<OperationOutcome> {
    let errorSuggestion: string | undefined
    let errorMessage: string | undefined

    if (this.shouldInstallCocoaPods) {
      const installResult = await installCocoaPods('1.10.1', this.shouldUpdateCocoaPods)

      if (!installResult.successful) {
        errorMessage = installResult.errorMessage
        errorSuggestion = installResult.errorSuggestion
      }
    }

    // Check Pod package ownership if required.
    if (!errorMessage && this.checkOwnership) {
      let tokenOwner: string | undefined
      const userResult = await cliExec({cli: 'pod', commandOrFlags: ['trunk', 'me']})

      if (userResult.code !== 0) {
        errorMessage = `Authorised user check failed: ${userResult.stderr || userResult.stdout}`
        errorSuggestion = 'Passed invalid CocoaPods token'
      }

      if (!errorMessage) {
        // Search for session (token) owner in response.
        const output = userResult.stdout || userResult.stderr
        const matches = output.match(/Name:\s+([a-zA-Z0-9 ]+)/m)
        if (matches != null && matches.length > 1) tokenOwner = matches[1]

        if (!new RegExp(this.packageName!, 'm').test(output)) {
          errorMessage = `${tokenOwner} doesn't have rights to push '${this.packageName}' pod.`
          errorSuggestion = 'Use CocoaPod token from one of package maintainers.'
        }
      }
    }

    if (!errorMessage) await cliExec({cli: 'pod', commandOrFlags: ['install']})

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  async fetchPackageInformation(): Promise<OperationOutcome> {
    let podspecContent = fs.readFileSync(this.specPath!).toString('utf8')
    let errorSuggestion: string | undefined
    let errorMessage: string | undefined

    if (podspecContent) {
      const spec = podspecContent.match(/Pod::Spec.new do \|(.*)\|/m)
      if (!spec || spec.length <= 1) {
        errorMessage = `Unexpected content of Podspec: ${this.specPath}`
        errorSuggestion = 'Podspec malformed, fix corrupted lines.'
      } else {
        const nameRegExp = new RegExp(`${spec[1]}\.name.*'([a-zA-Z0-9.]+)'.*`, 'm')
        const matchedName = podspecContent.match(nameRegExp)

        if (!matchedName || matchedName.length <= 1) {
          errorMessage = `'name' is missing from Podspec: ${this.specPath}`
          errorSuggestion = 'Make sure that required field is present in Podspec.'
        } else this.packageName = matchedName[1]

        if (!errorMessage) {
          const nameRegExp = new RegExp(`${spec[1]}\.version.*'([a-zA-Z0-9.]+)'.*`, 'm')
          const matchedVersion = podspecContent.match(nameRegExp)

          if (!matchedVersion || matchedVersion.length <= 1) {
            errorMessage = `'version' is missing from Podspec: ${this.specPath}`
            errorSuggestion = 'Make sure that required field is present in Podspec.'
          } else this.packageVersion = matchedVersion[1]
        }
      }
    } else {
      errorMessage = `'${path.basename(this.specPath!)}' is empty or contains non-UTF8 characters.`
      errorSuggestion = 'Ensure that file not empty and contains only valid characters.'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  override preBuildUserScript(): string {
    return 'pre-pod-build'
  }

  override prePublishUserScript(): string {
    return 'pre-pod-publish'
  }

  async publish(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined
    let commandOrFlags = ['trunk', 'push', `${this.specPath}`]
    if (this.allowWarnings) commandOrFlags.push('--allow-warnings')

    const execResult = await cliExec({cli: 'pod', commandOrFlags})
    if (execResult.code !== 0) {
      errorMessage = `Can't publish ${this.packageName} ${this.packageVersion}: ${execResult.stderr || execResult.stdout}`
      errorSuggestion = 'Check CocoaPod build logs and fix any mentioned warnings and errors.'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }
}

/** GitHub action runner entry point. */
async function run(): Promise<void> {
  await PodService.actionRunner(new PodService())
}

run()
