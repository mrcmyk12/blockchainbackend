import styles from 'ansi-styles'
import path from 'path'
import fs from 'fs'
import os from 'os'
import {UPLOAD_FOLDER_PATH} from '../../constants'
import {gitAdd, gitCheckBranchExists, gitCheckoutBranch, gitClone, gitCommit, gitPush} from '../../helpers/git'
import {action, getActionBooleanInput, getActionInput} from '../../helpers/actions'
import {getPagesInformation, setPagesInformation} from '../../helpers/github'
import {GitHubPages, OperationOutcome} from '../../helpers/types'
import {cliExec} from '../../helpers/cli'
import * as log from '../../helpers/log'
import * as Service from '../service'

class GitHubPagesService extends Service.ServiceBase {
  /** Branch which will be used git GitHub Pages site. */
  private branch!: string

  /** Relative path to folder with GitHub Pages site content. */
  private sourceFolder!: string

  /** Path to folder within specified branch where GitHub Pages site content is stored. */
  private pagesFolder!: '/' | '/docs'

  /**
   * Whether GitHub Action should setup Pages for repository (if not set).
   * This requires 'token' to be specified in workflow.
   */
  private shouldSetupPages: boolean = false

  /** Bash command which should be called before pushing pages. */
  private command?: string

  /** Existing GitHub Pages configuration. */
  private pagesInformation?: GitHubPages

  /** Path to which repository will be cloned for Pages manipulation. */
  private pagesClonePath!: string

  constructor() {
    super()

    // Pages should be configured on repository (if needed).
    this.shouldSetupServiceEnvironment = true

    // GitHub Pages doesn't require tag to be created.
    this.shouldCreateTag = false
  }

  serviceName(): string {
    return 'GitHub Pages'
  }

  secretValues(): string[] {
    return action.github.token ? [action.github.token] : []
  }

  environmentVariables(): Record<string, any> {
    return {}
  }

  readInput(): void {
    this.branch = getActionInput('branch', false)
    this.sourceFolder = this.productPath(getActionInput('source-folder', true))
    this.pagesFolder = getActionInput('pages-folder', false) as '/' | '/docs'
    this.command = getActionInput('command', false)
    this.pagesClonePath = this.productPath('github-pages-deploy')
    this.shouldSetupPages = getActionBooleanInput('setup-pages', false)
  }

  async verifyInput(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    if (!errorMessage && !this.branch) {
      errorMessage = 'GitHub Pages branch not set.'
      errorSuggestion = 'Check workflow and ensure that non-empty string is set for \'branch\'.'
    }

    if (!errorMessage && !this.pagesFolder) {
      errorMessage = 'GitHub Pages site content folder not set.'
      errorSuggestion = 'Check workflow and ensure that non-empty string is set for \'pages-folder\'.'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  async verifyServiceEnvironment(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    if (this.shouldSetupPages) {
      log.info(`Checking ${styles.bold.open}${action.repository.repo}${styles.bold.close} GitHub Pages configuration`)
      // Retrieve information about currently configured GitHub Pages (if configured).
      this.pagesInformation = await getPagesInformation(
        action.repository.owner,
        action.repository.repo
      )

      if (!this.pagesInformation.successful) {
        errorMessage = this.pagesInformation.errorMessage
        errorSuggestion = this.pagesInformation.errorSuggestion
      } else if (this.pagesInformation.configured && this.pagesInformation.branch !== this.branch) {
        errorMessage = `Wrong branch name is set: ${this.branch} (${this.slug()} configured with ${this.pagesInformation.branch}.`
        errorSuggestion = 'GitHub Pages uses different branch name already. Use same branch name in workflow.'
      } else {
        if (this.pagesInformation.configured)
          log.success(
            `${styles.bold.open}${action.repository.repo}${styles.bold.close} GitHub Pages configured on ${styles.bold.open}${this.pagesInformation.branch}${styles.bold.close} branch (path: ${styles.bold.open}${this.pagesInformation.path}${styles.bold.close})`
          )
        else
          log.success(
            `${styles.bold.open}${action.repository.repo}${styles.bold.close} GitHub Pages not configured.`
          )
      }
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  async setupServiceEnvironment(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined
    const configured = this.pagesInformation ? this.pagesInformation.configured : false
    let outcome: OperationOutcome | undefined

    const artifactsPath = this.artifactsPath ?? UPLOAD_FOLDER_PATH
    if (artifactsPath && !fs.existsSync(artifactsPath))
      fs.mkdirSync(artifactsPath, {recursive: true})

    // Clone repository to separate location, where it will be safe to modify.
    if (!outcome || outcome.successful) {
      log.info('Getting GitHub Pages site sources')
      outcome = await gitClone(action.repository.cloneUrl, this.pagesClonePath)
    }

    // Checkout GitHub Pages branch.
    if (!outcome || outcome.successful) {
      log.info(`Checking whether ${styles.bold.open}${this.branch}${styles.bold.close} branch exists`)
      let branchCheck = await gitCheckBranchExists(action.repository.cloneUrl, this.branch)
      outcome = branchCheck

      if (outcome.successful) {
        if (!branchCheck.exists)
          log.info(`Creating ${styles.bold.open}${this.branch}${styles.bold.close} orphan branch`)

        outcome = await gitCheckoutBranch(
          this.branch,
          {orphan: !branchCheck.exists, reset: !branchCheck.exists, depth: 1},
          branchCheck.exists,
          this.pagesClonePath
        )

        if (!branchCheck.exists && outcome.successful) {
          log.info(`Push ${styles.bold.open}${this.branch}${styles.bold.close} branch to remote`)
          outcome = await gitPush(this.pagesClonePath, this.branch)
        }
      }
    }

    if (this.shouldSetupPages && !configured) {
      log.info(
        `Configuring ${styles.bold.open}${action.repository.repo}${styles.bold.close} GitHub Pages on ${styles.bold.open}${this.branch}${styles.bold.close} branch (path: ${styles.bold.open}${this.pagesFolder}${styles.bold.close})`
      )
      outcome = await setPagesInformation(action.repository.owner, action.repository.repo, this.branch, this.pagesFolder)
    }

    if (outcome && !outcome.successful) {
      errorMessage = outcome.errorMessage
      errorSuggestion = outcome.errorSuggestion
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  async fetchPackageInformation(): Promise<OperationOutcome> {
    return {successful: true}
  }

  override preBuildUserScript(): string {
    return 'pre-github-pages-build'
  }

  // @ts-ignore Async doesn't override properly.
  async build(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    // Exec custom command (if has been set).
    if (this.command) {
      log.info('Running custom pages build command')

      const commandOrFlags = this.command.split(' ')
      const cli = commandOrFlags.shift()

      const execResult = await cliExec({cli: cli!, commandOrFlags})

      if (execResult.code !== 0) {
        errorMessage = `Unable to run provided build command: ${execResult.stderr || execResult.stdout}`
        errorSuggestion = 'Check syntax and ensure that all required dependencies installed.'
      }
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  override prePublishUserScript(): string {
    return 'pre-github-pages-publish'
  }

  async publish(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined
    let pagesContentChanged: boolean | undefined
    let outcome: OperationOutcome | undefined

    if (!fs.existsSync(this.sourceFolder)) {
      errorMessage = `GitHub Pages site content folder not found: ${this.sourceFolder}`
      errorSuggestion = 'Ensure that content has been built and proper path is set relative to product in workflow.'
    }

    if (!action.isRegularPush && this.releaseProcessInformation && this.releaseProcessInformation.product) {
      if (!this.releaseProcessInformation.product.main) {
        log.info(`${this.releaseProcessInformation.product.name} is not main product. Skip GitHub Pages update.`)
        this.shouldSkipRestSteps = true
        return {successful: true}
      }
    }

    if (!errorMessage) {
      log.info('Coping files from source folder')
      const targetPath = path.join(this.pagesClonePath, this.pagesFolder === '/' ? '' : this.pagesFolder)

      if (!fs.existsSync(targetPath)) fs.mkdirSync(targetPath, {recursive: true})

      // Ensure that site content really should be moved.
      if (targetPath !== this.sourceFolder) {
        let commandOrFlags = [
          '-dlptr',
          '--exclude',
          '.ssh',
          '--exclude',
          '.git',
          '--exclude',
          '.github',
          '--delete',
          `${this.sourceFolder}/`,
          `${targetPath}/`
        ]

        // Copy files from source directory to target
        const syncResults = await cliExec({cli: 'rsync', commandOrFlags})
        if (syncResults.code !== 0) {
          errorMessage = `Unable to complete files synchronisation: ${syncResults.stderr || syncResults.stdout}`
          errorSuggestion = 'Make sure that specified source folder exists.'
        } else log.info('Files has been copied source folder')
      }
    }

    // Check whether there is changes on pages branch.
    if (!errorMessage) {
      const changesResult = await cliExec({
        cli: 'git',
        commandOrFlags: ['status', '--porcelain'],
        execOptions: {cwd: this.pagesClonePath}
      })

      if (changesResult.code === 0)
        pagesContentChanged = changesResult.stdout.split(os.EOL).length >= 1
      else {
        errorMessage = `Unable to get status on pages branch: ${changesResult.stderr || changesResult.stdout}`
        errorSuggestion = 'Check git status call output.'
      }
    }

    // Add any new files in pages branch.
    if (!errorMessage) {
      if (pagesContentChanged) {
        log.info('Committing and pushing changes to GitHub Pages site')
        outcome = await gitAdd(this.pagesClonePath)
      } else log.success('GitHub Pages site is up-to-date')
    }

    // Commit changes if required.
    if (outcome && outcome.successful) {
      let commitMessage = 'Update GitHub Pages site for current product release'

      if (!action.isRegularPush && this.releaseProcessInformation && this.releaseProcessInformation.product && this.releaseProcessInformation.changelog)
        commitMessage = `Update pages for ${this.releaseProcessInformation.product.name} ${this.releaseProcessInformation.changelog.version} release.`
      outcome = await gitCommit(commitMessage, this.pagesClonePath)
    } else if (!outcome) log.info('There is no changes to commit')

    // Push changes to remote.
    if (outcome && outcome.successful)
      outcome = await gitPush(this.pagesClonePath, this.branch, undefined, true)
    else log.success('Remote git branch is up-to-date')

    // Clean up main repository after GitHub Pages deployment.
    // @ts-ignore
    fs.rmdirSync(this.pagesClonePath, {recursive: true, force: true})

    if (outcome && !outcome.successful) {
      errorMessage = outcome.errorMessage
      errorSuggestion = outcome.errorSuggestion
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }
}

/** GitHub action runner entry point. */
async function run(): Promise<void> {
  await GitHubPagesService.actionRunner(new GitHubPagesService())
}

run()
