import fse from 'fs-extra'
import path from 'path'
import fs from 'fs'
import {getActionBooleanInput, getActionInput} from '../../helpers/actions'
import {checkRubyVersion} from '../../installers/install-ruby'
import {cliExec, CLIExecResult} from '../../helpers/cli'
import {UPLOAD_FOLDER_PATH} from '../../constants'
import * as Service from '../service'
import {OperationOutcome} from '../../helpers/types'

/** Gem service package handler. */
class GemService extends Service.ServiceBase {
  /** Whether it is required to ensure token owner rights to publish package. */
  private checkOwnership?: boolean

  /**
   * Full path to location of `.gemspec` file. Service will try to locate it if not passed in GitHub Action
   * configuration.
   * @private
   */
  private gemspecPath?: string

  /** RubyGem account which should be used to author release. */
  private username!: string

  /** RubyGems API access token with permissions to publish target package. */
  private token!: string

  constructor() {
    super()

    // Dependencies should be installed before publish.
    this.shouldSetupServiceEnvironment = true
  }

  serviceName(): string {
    return 'gem'
  }

  secretValues(): string[] {
    return [this.username, this.token]
  }

  environmentVariables(): Record<string, any> {
    return {}
  }

  readInput(): void {
    this.token = getActionInput('gem-token', true)
    this.username = getActionInput('gem-username', true)!
    this.gemspecPath = this.filePath({endsWith: '.gemspec'}, getActionInput('gemspec-path', false))
    this.checkOwnership = getActionBooleanInput('check-gem-ownership', false, 'true')
    this.buildPath = this.productPath(getActionInput('build-path', false, UPLOAD_FOLDER_PATH))
    this.artifactsPath = this.productPath(getActionInput('artifacts-path', false, UPLOAD_FOLDER_PATH), true)

    this.artifactsFilter = getActionInput('artifacts-filter', false, '')
      .split(',')
      .filter(filter => filter.length > 0)

    if (!this.buildPath.endsWith('.gem')) this.buildPath = path.join(this.buildPath, this.gemFileName())
  }

  async verifyInput(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    if (!this.gemspecPath) errorMessage = 'Gemspec file path not set.'
    else if (!fs.existsSync(this.gemspecPath)) {
      errorMessage = `'${path.basename(this.gemspecPath)}' file not found: ${path.dirname(this.gemspecPath)}`
      errorSuggestion = 'Make sure that proper relative path has been set (present in product directory for monorepo).'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  // @ts-ignore Async doesn't override properly.
  async updateServiceSettings(): Promise<OperationOutcome> {
    const outcome = await super.updateServiceSettings()

    if (outcome.successful) {
      const gemPath = path.join(process.env['HOME']!, '.gem')
      const gemConfigPath = path.join(gemPath, 'credentials')

      if (!fs.existsSync(gemPath)) fs.mkdirSync(gemPath, {recursive: true})
      this.markChangedSettingsFile(gemConfigPath)

      const configuration = `---
:rubygems_api_key: ${this.token}`

      fs.writeFileSync(gemConfigPath, configuration, {encoding: 'utf8'})
      fs.chmodSync(gemConfigPath, 0o600)
    }

    return outcome
  }

  async verifyServiceEnvironment(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined

    // Check whether minimum required Ruby version installed.
    const rubyCheckResult = await checkRubyVersion(2, 6)
    if (!rubyCheckResult.match) {
      errorMessage = rubyCheckResult.errorMessage
      errorSuggestion = rubyCheckResult.errorSuggestion
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  async setupServiceEnvironment(): Promise<OperationOutcome> {
    let errorMessage, errorSuggestion: string | undefined
    let execResult: CLIExecResult | undefined

    // Check gem package ownership if required.
    if (this.checkOwnership) {
      execResult = await cliExec({cli: 'gem', commandOrFlags: ['owner', this.packageName!]})

      if (execResult.code === 0) {
        if (!new RegExp(`- ${this.username}`, 'm').test(execResult.stdout)) {
          errorMessage = `${this.username} not listed in ${this.packageName} package owners.`
          errorSuggestion = `Add ${this.username} as ${this.packageName} package owner or use different account.`
        }
      } else {
        errorMessage = execResult.stderr || execResult.stdout
        errorSuggestion =
          'Check whether Ruby components properly installed or not.'
      }
    }

    let gemAction = 'bundle install --without development'

    if (execResult && execResult.code === 0) {
      execResult = await cliExec({cli: 'sudo', commandOrFlags: ['gem', 'update', '--system']})
      gemAction = 'sudo gem update --system'
    }
    if (execResult && execResult.code === 0) {
      execResult = await cliExec({cli: 'sudo', commandOrFlags: ['gem', 'install', 'bundler']})
      gemAction = 'sudo gem install bundler'
    }
    if (execResult && execResult.code === 0) {
      execResult = await cliExec({cli: 'sudo', commandOrFlags: ['gem', 'update', 'bundler']})
      gemAction = 'sudo gem update bundler'
    }
    if (execResult && execResult.code === 0)
      execResult = await cliExec({cli: 'bundle', commandOrFlags: ['install', '--without', 'development']})

    if (!errorMessage && execResult && execResult.code !== 0) {
      errorMessage = `Failed to run '${gemAction}': ${execResult.stderr || execResult.stdout}`
      errorSuggestion = 'Check whether \'Gemfile\' not malformed and runner has required permissions to install dependencies.'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  async fetchPackageInformation(): Promise<OperationOutcome> {
    const gemspecContent = fs.readFileSync(this.gemspecPath!).toString('utf8')
    let errorMessage, errorSuggestion: string | undefined

    if (gemspecContent) {
      const spec = gemspecContent.match(/Gem::Specification.new do \|(.*)\|/m)
      if (!spec || spec.length <= 1) {
        errorMessage = `Unexpected Gemspec content: ${this.gemspecPath}`
        errorSuggestion = 'Gemspec malformed, fix corrupted lines.'
      } else {
        const nameRegExp = new RegExp(`${spec[1]}\.name.*'([a-zA-Z0-9 ]+)'.*`, 'm')
        const matchedName = gemspecContent.match(nameRegExp)

        if (!matchedName || matchedName.length <= 1) {
          errorMessage = `'name' field is missing from Gemspec: ${this.gemspecPath}`
          errorSuggestion = 'Make sure that required field is present in Gemspec.'
        } else this.packageName = matchedName[1]
      }
    } else {
      errorMessage = 'Gemspec is empty or contains non-UTF8 characters.'
      errorSuggestion = 'Ensure that file not empty and contains only valid characters.'
    }

    return {successful: !errorMessage, errorMessage, errorSuggestion}
  }

  override preBuildUserScript(): string {
    return 'pre-gem-build'
  }

  // @ts-ignore Async doesn't override properly.
  async build(): Promise<OperationOutcome> {
    await super.build()

    let gemArtifactFolder = this.buildPath

    if (gemArtifactFolder) {
      if (gemArtifactFolder.endsWith('.gem')) gemArtifactFolder = path.dirname(gemArtifactFolder)

      if (!fs.existsSync(gemArtifactFolder)) fs.mkdirSync(gemArtifactFolder, {recursive: true})
    }

    const buildResult = await cliExec({
      cli: 'gem',
      commandOrFlags: ['build', this.gemspecPath!, '--output', this.buildPath!]
    })

    if (buildResult.code === 0 && this.artifactsPath && this.buildPath) {
      if (this.artifactsPath !== gemArtifactFolder && !fs.existsSync(this.artifactsPath))
        fs.mkdirSync(this.artifactsPath, {recursive: true})
      if (this.artifactsPath !== gemArtifactFolder) {
        if (fs.existsSync(gemArtifactFolder!) && fs.readdirSync(gemArtifactFolder!).length > 0)
          fse.copySync(this.buildPath, this.artifactsPath, {filter: this.artifactsFilterFunction()})
      }
    }

    return {
      successful: buildResult.code === 0,
      errorMessage: buildResult.code !== 0 ? buildResult.stderr || buildResult.stdout : undefined
    }
  }

  override prePublishUserScript(): string {
    return 'pre-gem-publish'
  }

  async publish(): Promise<OperationOutcome> {
    const publishResult = await cliExec({cli: 'gem', commandOrFlags: ['push', this.buildPath!]})

    return {
      successful: publishResult.code === 0,
      errorMessage: publishResult.code !== 0 ? publishResult.stderr || publishResult.stdout : undefined
    }
  }

  /**
   * Compose name of gemfile based on module name and target module version.
   *
   * @return {string} Name which should be used for built gem file.
   * @private
   */
  private gemFileName(): string {
    let pubnubYML = fs.readFileSync(this.productPath('.pubnub.yml', true)).toString('utf8')
    let versionMatches = new RegExp("^version: \"(.*)\"", 'gm').exec(pubnubYML)
    let gemspec = fs.readFileSync(this.gemspecPath!).toString('utf8')
    const specNameMatch = new RegExp('^Gem::Specification.new do \\|(.*)\\|$', 'gm').exec(gemspec);
    let nameComponents: string[] = []

    if (specNameMatch && specNameMatch.length > 1) {
      const moduleNameMatch = new RegExp(`^\\s{2,}${specNameMatch[1]}.name = '(.*)'$`, 'gm').exec(gemspec);
      if (moduleNameMatch && moduleNameMatch.length > 1)
        nameComponents.push(moduleNameMatch[1])
    }

    if (versionMatches && versionMatches.length > 1)
      nameComponents.push(versionMatches[1])


    return `${nameComponents.join('-')}.gem`
  }
}

/** GitHub action runner entry point. */
async function run(): Promise<void> {
  await GemService.actionRunner(new GemService())
}

run()
