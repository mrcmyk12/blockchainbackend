import * as github from '@actions/github'
import * as core from '@actions/core'
import styles from 'ansi-styles'
import path from 'path'
import fs from 'fs'
import {fetchReleaseForVersion, jiraProjectKey, repositoryProductName} from '../helpers/jira'
import {notifySlackChannelReleaseStart} from '../helpers/slack'
import {applyChangelog, Changelog, fetchCurrentVersion, generateChangelogUsingPRInformation, nextVersion} from './changelog'
import {getEventInformation, uploadArtifact, action, productInformation, getActionInput} from '../helpers/actions'
import {JIRAProjectRelease, OperationOutcome, ReleaseProcessOutcome} from '../helpers/types'
import {emailForUsername, getIssueInformation, publishComment} from '../helpers/github'
import {gitAdd, gitClone, gitCommit, gitPush, setupGit} from '../helpers/git'
import {productPath, productsJSONPath} from '../helpers/paths'
import {ACTION_WORKING_DIR_PATH} from '../constants'
import {execUserScript} from '../helpers/cli'
import * as log from '../helpers/log'

/** Object represent command sent by user as comment to PR. */
type UserCommand = OperationOutcome & {
  /** GitHub username which is mentioned at the comment beginning. */
  mention?: string

  /**
   * Detected command in published comment.
   *
   * At this moment supported: release, help
   */
  command?: 'release' | 'help'

  /**
   * Name of product in monorepo for which command should be applied.
   *
   * @default default
   */
  product: string

  /**
   * Version under which target / default project should be released.
   *
   * @default Decided by script after change log analysis in PR initial message.
   */
  version?: string
}

/**
 * Check whether comment / command sender has permissions to exec it or not (is member of organization).
 *
 * @param {string} sender GitHub username of person who sent command.
 *
 * @return {Promise<OperationOutcome>} Asynchronous results of permissions check.
 */
const verifyPermissions = async (sender: string): Promise<OperationOutcome> => {
  // @ts-ignore At least one of tokens will be specified, or exception will be thrown.
  const token: string = action.github.token || action.github.ghToken
  let errorMessage, errorSuggestion: string | undefined
  const octokit = github.getOctokit(token)

  try {
    await octokit.request('GET /orgs/{owner}/members/{username}', {owner: action.repository.owner, username: sender})
  } catch (error) {
    errorMessage = `${sender} not allowed to exec commands`
    errorSuggestion = `Ensure that ${sender} is part of ${action.repository.owner} organization.`
  }

  return {successful: !errorMessage, errorMessage, errorSuggestion}
}

/**
 * Pre-process comment body and extract command which should be executed.
 *
 * @param {string} listener GitHub username which should be mentioned at the comment beginning.
 * @param {string} command Comment body which should be processed.
 *
 * @return {UserCommand} Parsed command information.
 */
const parsedCommand = (listener: string, command: string): UserCommand => {
  let errorMessage, errorSuggestion: string | undefined
  const productsFilePath = productsJSONPath()
  let commandRecipient: string | undefined
  let cmd: UserCommand['command']
  let product: string | undefined
  let version: string | undefined

  const matchedListener = command.match(/^@([a-zA-Z0-9.\-_]*)/m)
  if (matchedListener && matchedListener.length > 0)
    commandRecipient = matchedListener[1]
  else {
    errorMessage = 'Malformed command'
    errorSuggestion = 'Ensure that command sent following this pattern: @<recipient> <command> [what] [as [version]]'
  }

  // Ensure that proper recipient has been specified.
  if (commandRecipient !== listener) {
    errorMessage = `Unknown command recipient: ${commandRecipient}`
    errorSuggestion = 'Ensure that proper recipient mentioned in comment.'
  }

  if (!errorMessage) {
    const cmdArguments = command.split(' ').slice(1)
    const supportedCommands = ['release', 'help']

    if (cmdArguments.length > 0) {
      if (supportedCommands.includes(cmdArguments[0])) cmd = cmdArguments[0] as UserCommand['command']
      else {
        errorMessage = `Unknown command has been sent: ${cmdArguments[0]}`
        errorSuggestion = `Ensure that command is one of: ${supportedCommands.join(
          ', '
        )}`
      }

      if (!errorMessage && cmd === 'release') {
        // Parse target project information.
        if (cmdArguments.length > 1) {
          if (cmdArguments[1] !== 'as') product = cmdArguments[1]
          else if (cmdArguments.length > 2) version = cmdArguments[2]
        }

        if (!version && cmdArguments.length > 3 && cmdArguments[2] === 'as') version = cmdArguments[3]
      }
    } else {
      errorMessage = 'Command missing'
      errorSuggestion =
        'Ensure that command sent following this pattern: @<recipient> <command> <what> as <version>'
    }
  }

  if (!product) product = '.root-project'

  if (!errorMessage && cmd === 'release' && productsFilePath) {
    const pathToProject = path.join(action.rootWorkingDirectory, ACTION_WORKING_DIR_PATH, 'product-path')

    const projectsJSON = product !== '.root-project' ? productInformation(product) : undefined

    if (product === '.root-project') fs.writeFileSync(pathToProject, '.', {encoding: 'utf8'})
    else {
      if (projectsJSON) {
        fs.writeFileSync(pathToProject, projectsJSON.path, {encoding: 'utf8'})
      } else if (projectsJSON === undefined) {
        errorMessage = `Projects ${path.dirname(productsFilePath)} is empty or ${product} path not found in ${
          path.dirname(productsFilePath)
        }.`
        errorSuggestion = `Repository probably not configured as monorepo or ${product} not defined in ${path.dirname(
          productsFilePath
        )}`
      } else {
        errorMessage = `Unable to select ${product} because ${path.basename(
          productsFilePath
        )} not found or contains non-UTF8 characters: ${path.dirname(
          productsFilePath
        )}`
        errorSuggestion = `Ensure that ${path.basename(
          productsFilePath
        )} committed to repository and readable and contains only valid characters.`
      }
    }
  }

  return {
    mention: listener === commandRecipient ? listener : undefined,
    command: cmd,
    product,
    version,
    successful: !errorMessage,
    errorMessage,
    errorSuggestion
  }
}

/**
 * Publish instruction on what commands can be used.
 *
 * @param {string} sender GitHub username of person which sent `help` command.
 */
const publishHelpComment = async (sender: string): Promise<OperationOutcome> => {
  const message =
    `@${sender} some information which may help you listed below.\n` +
    '<details>\n<summary>Available commands and options</summary>\n<br />\n\n' +
    'List of comments which can trigger deployment action:\n' +
    '- `@client-engineering-bot help` to get this information\n' +
    '- `@client-engineering-bot release [<project>] [as [<version>]]` complete preparation before merge to default ' +
    'branch.\n' +
    '  - `project` - _optional_ identifier of project from `.github/workflows/release/products.json` which should be' +
    ' released.\n' +
    '     By default repository root will be used.\n' +
    '  - `version` - _optional_ custom version with which release should be done.\n' +
    '     By default next version is based on changes mentioned in initial PR comment.\n' +
    '</details>'

  return await publishComment(action.repository.owner, action.repository.repo, action.issue.number, message)
}

/**
 * Generate changelog.
 *
 * @param {string} product Name of product which will be released.
 * @param {string} version Expected next production version.
 *
 * @return {Promise<ReleaseProcessOutcome>} Asynchronous results of changelog generation.
 */
const generateChangelog = async (product: string, version?: string | null): Promise<ReleaseProcessOutcome> => {
  let errorMessage, errorSuggestion: string | undefined
  let changelog: Changelog | undefined
  let productName: string | undefined
  let main = true

  log.info(`Fetch ${styles.bold.open}${action.issue.number}${styles.bold.close} information`)
  const issue = await getIssueInformation(
    action.repository.owner,
    action.repository.repo,
    action.issue.number,
    true
  )

  if (issue.successful) {
    log.success(
      `${styles.bold.open}${action.issue.number}${
        styles.bold.close
      } issue authored by ${styles.bold.open}${issue.creator!}${
        styles.bold.close
      } fetched`
    )
  } else {
    errorMessage = issue.errorMessage
    errorSuggestion = issue.errorSuggestion
  }

  if (!errorMessage) {
    log.info('Analyse changes information')
    changelog = await generateChangelogUsingPRInformation(issue)

    if (changelog.successful)
      log.success(`${styles.bold.open}${changelog.entries.length}${styles.bold.close} changes has been parsed.`)
    else {
      errorMessage = changelog.errorMessage
      errorSuggestion = changelog.errorSuggestion
    }
  }

  // Decide on next release version.
  if (!errorMessage && changelog) {
    log.info('Decide on next release version number')

    if (!version) {
      version = fetchCurrentVersion()

      if (version) version = nextVersion(version, changelog)
    }

    if (version) {
      log.success(`Release as ${styles.bold.open}${version}${styles.bold.close}.`)
      changelog.version = version

      // Store changelog under .github/.release so it will be available for custom script,
      // which called before changes commit.
      const changelogPath = path.join(action.rootWorkingDirectory, ACTION_WORKING_DIR_PATH, 'changelog.json')
      fs.writeFileSync(changelogPath, JSON.stringify(changelog), {encoding: 'utf8'})
    } else {
      errorMessage = 'Unable decide on next release version'
      errorSuggestion =
        "Configured version bump patterns doesn't match / capture any versions."
    }
  }

  if (product === '.root-project') productName = action.repository.repo
  else {
    productName = productInformation(product)!.name
    main = productInformation(product)!.main ?? main
  }

  if (!errorMessage && changelog && changelog.version && issue.type === 'pull-request') {
    const decidedProductPath = productPath()
    const clonePath = path.join(action.rootWorkingDirectory, ACTION_WORKING_DIR_PATH, issue.head!.repo)

    // Making local copy of branch which contains released code.
    const cloneOutcome = await gitClone(issue.head!.cloneUrl, clonePath, issue.head!.ref)

    if (cloneOutcome.successful && decidedProductPath) {
      const productDirectory = path.join(clonePath, decidedProductPath)
      let outcome = await applyChangelog(changelog, clonePath, productDirectory, main)

      // Try call any user-defined pre-publish scripts (bash, NodeJS).
      if (outcome.successful) outcome = await execUserScript('pre-publish', clonePath, false)

      if (outcome.successful) outcome = await gitAdd(clonePath)
      if (outcome.successful) outcome = await gitCommit(`PubNub SDK ${changelog.version} release.`, clonePath)
      if (outcome.successful) outcome = await gitPush(clonePath)

      if (!outcome.successful) {
        errorMessage = outcome.errorMessage
        errorSuggestion = outcome.errorSuggestion
      }
    } else {
      errorMessage = cloneOutcome.errorMessage
      errorSuggestion = cloneOutcome.errorSuggestion
    }
  }

  return {
    changelog,
    product: { name: productName, path: productPath(), main },
    completedSteps: [],
    successful: !errorMessage,
    errorMessage,
    errorSuggestion
  }
}

/** GitHub Action entry point. */
async function run(): Promise<void> {
  let cmd: UserCommand | undefined
  let outcome: OperationOutcome

  try {
    const listener = core.getInput('listener', {required: true})
    const token = core.getInput('token', {required: true})
    const jiraAPIKey = getActionInput('jira-api-key')

    // Hiding token from console output.
    core.setSecret(token)

    // Read JSON file with triggering event information.
    const eventInformation = getEventInformation(true)
    outcome = eventInformation

    // Check whether comment sender has permissions to execute commands or not.
    if (outcome.successful) {
      core.startGroup('Verify permissions')
      outcome = await verifyPermissions(eventInformation.sender)
      if (outcome.successful) {
        log.success(`${styles.bold.open}${eventInformation.sender}${styles.bold.close} allowed to exec commands.`)
        core.endGroup()
      }
    }

    // Analyse command which has been sent in comment to PR.
    if (outcome.successful) {
      core.startGroup('Parse command')
      cmd = parsedCommand(listener, eventInformation.command!)
      outcome = cmd
      if (outcome.successful) {
        log.success(`${styles.bold.open}${cmd.command}${styles.bold.close} detected.`)
        core.endGroup()
      }
    }

    if (outcome.successful && cmd) {
      if (cmd.command === 'help') {
        core.startGroup('Publish help information')
        outcome = await publishHelpComment(eventInformation.sender)
        if (outcome.successful) {
          log.success('Release action help information has been published.')
          core.endGroup()
        }
      } else if (cmd.command === 'release') {
        // Setup git to make it possible make changes in branch.
        await setupGit(action.bot.name, emailForUsername(action.bot.name))

        core.startGroup('Generate changelogs')
        const releaseOutcome = await generateChangelog(cmd.product, cmd.version)
        outcome = releaseOutcome

        if (outcome.successful) {
          log.success('Changelog generated')
          core.endGroup()

          core.startGroup('Upload changelog artifacts')

          const artifactData = JSON.stringify({changelog: releaseOutcome.changelog, product: releaseOutcome.product})
          outcome = await uploadArtifact(artifactData, `release-artifacts-${action.issue.number}.json`)

          if (outcome.successful) {
            log.success('Artifacts uploaded')
            core.endGroup()
          }
        }

        if (outcome.successful) {
          const releaseProcess: ReleaseProcessOutcome = {
            changelog: releaseOutcome.changelog,
            product: releaseOutcome.product,
            completedSteps: [],
            successful: true
          }

          let jiraReleaseVersion: JIRAProjectRelease | undefined = undefined
          if (releaseProcess.changelog?.version && jiraAPIKey && jiraAPIKey.length > 0) {
            core.startGroup('Notify Slack channels about deployment completion.')
            const projectKey = jiraProjectKey()

            if (projectKey) {
              jiraReleaseVersion = await fetchReleaseForVersion(releaseProcess.changelog.version, jiraAPIKey)
              let product = repositoryProductName()

              if (productsJSONPath() && releaseProcess.product && releaseProcess.product.name)
                product = releaseProcess.product.name
              if (jiraReleaseVersion) log.success(`${styles.bold.open}${product}${styles.bold.close} JIRA release retrieved.`)
              else log.warning(`${styles.bold.open}${product}${styles.bold.close} doesn't have JIRA release.`)
            } else log.success(`${styles.bold.open}${action.repository.repo}${styles.bold.close} doesn't require report to Slack channel.`)
          }

          outcome = await notifySlackChannelReleaseStart(releaseProcess, jiraReleaseVersion)
          core.endGroup()
        }
      }
    }

    if (outcome.errorSuggestion) core.warning(outcome.errorSuggestion)
    if (outcome.errorMessage) core.setFailed(outcome.errorMessage)
    if (!outcome.successful) core.endGroup()
  } catch (error) {
    core.setFailed(error.message)
  }
}

run()
