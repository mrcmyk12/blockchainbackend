import {inc, clean} from 'semver'
import YAML from 'yaml'
import path from 'path'
import fs from 'fs'
import {capitalizedString, lowerCasedString, replaceString} from '../helpers/string'
import {GitHubIssue, GitHubPullRequest, OperationOutcome} from '../helpers/types'
import {getIssueInformation, getIssuesInformation} from '../helpers/github'
import {productPath, versionsJSONPath} from '../helpers/paths'
import {action} from '../helpers/actions'

/** Match type for version bump in files. */
type VersionMatch = { pattern: string; cleared?: boolean; clearedPrefix?: boolean; clearedSuffix?: boolean, versionComponents?: number }

/** Version components type. */
type VersionComponents = { prefix?: string; version: string | null; suffix?: string }

/** Files for version bumping. */
type VersionsMatch = Record<string, VersionMatch[]>

/** Known change types. */
type ChangeType = 'build' | 'ci' | 'docs' | 'feat' | 'feature' | 'fix' | 'perf' | 'performance' | 'refactor' | 'style' | 'test'
  | 'unknown'

/** List of change types which is worth to bump minor version. */
const minorChanges = ['feat', 'feature', 'perf', 'performance']

/** List of change types which is worth to bump patch version. */
const patchChanges = ['build', 'fix', 'refactor', 'style']

/** Base addressed issue information representation. */
export type AddressedIssue = {
  /** GitHub username of issue author. */
  author: string

  /** Issue number. */
  issue: number

  /** Whether issue still opened or closed. */
  state: 'open' | 'closed'

  /** Whether author suggested changes with pull request or not. */
  isPullRequest: boolean
}

/** Single changelog entry representation. */
export type ChangeEntry = {
  /** Change entry type. */
  type: ChangeType

  /** Whether change is breaking and require major version bump. */
  isBreaking: boolean

  /** Context within which change has been done: separate API, specific docs section, etc. */
  context?: string

  /** Short change entry description. */
  title: string

  /** Longer change purpose description. */
  description?: string

  /** Description for breaking change. */
  breakingDescription?: string

  /** List if issue / pull request identifiers for which changes has been done. */
  addressedIssues?: AddressedIssue[]
}

/** Change log representation. */
export type Changelog = OperationOutcome & {
  /** List of entries. */
  entries: ChangeEntry[]

  /** Decided release version number. */
  version?: string

  /** Whether changelog contains any breaking changes mentioned. */
  hasBreakingChanges: boolean
}

/**
 * Generate changelog using PR number.
 *
 * @param {number} number Target issue number.
 *
 * @return {Promise<Changelog>} Asynchronously generated changelog.
 */
export const generateChangelogUsingPRNumber = async (number: number): Promise<Changelog> => {
  const information = await getIssueInformation(action.repository.owner, action.repository.repo, number, true)
  return await generateChangelogUsingPRInformation(information)
}

/**
 * Generate changelog using pull request issue information.
 *
 * @param {GitHubIssue} information Pull request issue which should be used for changelog generation.
 *
 * @return {Promise<Changelog>} Asynchronously generated changelog from pull request body.
 */
export const generateChangelogUsingPRInformation = async (information: OperationOutcome & (GitHubIssue | GitHubPullRequest)): Promise<Changelog> => {
  const knownChangeTypes = ['build', 'ci', 'docs', 'feat', 'feature', 'fix', 'perf', 'performance', 'refactor', 'style', 'test']
  const titleRegex = new RegExp(`^(${knownChangeTypes.join('|')})(.*)?: (.*)`, 'm')
  let changelog: Changelog = {entries: [], hasBreakingChanges: false, successful: true}
  let errorMessage, errorSuggestion: string | undefined
  let currentObjectIdx = 0
  let currentValue = ''

  if (information.successful && information.body) {
    const bodyLines = information.body.split(/\r?\n/)

    for (let lineIdx = 0; lineIdx < bodyLines.length; lineIdx++) {
      const line = bodyLines[lineIdx]

      if (line) {
        if (titleRegex.test(line)) {
          const matchedTitle = line.match(titleRegex)
          const type = (matchedTitle && matchedTitle.length > 1 ? matchedTitle[1] : 'unknown') as ChangeType
          const context = matchedTitle && matchedTitle.length > 2 ? matchedTitle[2] : undefined
          const title = matchedTitle && matchedTitle.length > 3 ? matchedTitle[3] : ''

          changelog.entries.push({type, isBreaking: false, context, title})
          currentObjectIdx = changelog.entries.length - 1
        } else currentValue += currentValue.length ? ` ${line}` : line
      }

      let entry: ChangeEntry | undefined = currentObjectIdx < changelog.entries.length ? changelog.entries[currentObjectIdx] : undefined
      if (entry && (!line || lineIdx === bodyLines.length - 1)) {
        if (!entry.description) entry.description = currentValue
        else {
          if (currentValue.indexOf('BREAKING CHANGES:') >= 0) {
            const matchedDescription = currentValue.match(/^BREAKING CHANGES: (.*)/m)
            if (matchedDescription && matchedDescription.length > 1)
              entry.breakingDescription = matchedDescription[1]
            changelog.hasBreakingChanges = true
            entry.isBreaking = true
          }

          let addressedIssueNumbers = (currentValue.match(/#(\d+)/gm) || []).map(issue => parseInt(issue.substring(1), 10))
          if (addressedIssueNumbers.length) {
            let issues = await getIssuesInformation(action.repository.owner, action.repository.repo, addressedIssueNumbers)
            let addressedIssues: AddressedIssue[] = []

            if (issues.successful) {
              for (let issueInformation of issues.issues!) {
                addressedIssues.push({
                  author: issueInformation.creator,
                  issue: issueInformation.number,
                  state: issueInformation.state as AddressedIssue['state'],
                  isPullRequest: issueInformation.isPullRequest ?? false
                })
              }
            } else {
              errorMessage = issues.errorMessage
              errorSuggestion = issues.errorSuggestion
            }

            entry.addressedIssues = addressedIssues
          }
        }

        currentValue = ''
      }
    }
  }

  if (errorMessage) {
    changelog.successful = false
    changelog.errorMessage = errorMessage
    changelog.errorSuggestion = errorSuggestion
  }

  return changelog
}

/**
 * Process generated changelog.
 * Function will checkout PR base branch and update files in it.
 *
 * @param {Changelog} changelog Result of PR body processing.
 * @param {string} rootDirectory Full path to location, where target repository root located.
 * @param {string} workingDirectory Full path to product directory within which files should be modified.
 * @param {boolean} mainProduct Whether building change log for main product or not (main product stores `.pubnub.yml` in
 * repository root folder)
 */
export const applyChangelog = async (
  changelog: Changelog,
  rootDirectory: string,
  workingDirectory: string,
  mainProduct: boolean
): Promise<OperationOutcome> => {
  const changelogFiles = ['.pubnub.yml', 'CHANGELOG.md', 'CHANGELOG.txt', 'CHANGELOG']
  const versions = versionsJSON()

  for (const fileName of changelogFiles) {
    const decidedWorkingDirectory = mainProduct && fileName === '.pubnub.yml' ? rootDirectory : workingDirectory
    const type = path.extname(fileName).replace('.', '') || 'txt'
    const filePath = path.join(decidedWorkingDirectory, fileName)

    if (fs.existsSync(filePath)) {
      let fileContent = fs.readFileSync(filePath).toString('utf8')
      // @ts-ignore
      const changes = changelogByType(changelog, type, false)

      if (fileContent && changes.length) {
        if (type !== 'yml') fileContent = changes + fileContent
        else
          fileContent = fileContent.replace(
            'changelog:',
            `changelog:
${changes}`
          )

        // Storing changelog.
        fs.writeFileSync(filePath, fileContent)
      }
    }
  }

  // Bump version if it is known what should be used.
  if (changelog.version)
    bumpVersions(changelog.version, mainProduct, rootDirectory, workingDirectory, versions)

  return {successful: true}
}

/**
 * Create change entries from generated changelog with specified layout type.
 *
 * @param {Changelog} changelog Generated changelog which should be used to generate Markdown.
 * @param {'md'|'txt'|'yml'} outputType One of possible changelog output formats.
 * @param {boolean} github Whether Markdown generated for GitHub release page or not.
 *
 * @return {string} Markdown string which can be prepended
 */
export const changelogByType = (changelog: Changelog, outputType: 'md' | 'txt' | 'yml', github: boolean = false): string => {
  let sections: { added: string[]; fixed: string[]; modified: string[] } = {added: [], fixed: [], modified: []}
  let header: string
  let body = ''

  if (!github) {
    if (outputType == 'md') {
      header = `## ${versionWithAdjustedComponentsCount(changelog.version!, 3)}
${humanReadableDate()}`
    } else if (outputType == 'txt') {
      header = `${versionWithAdjustedComponentsCount(changelog.version!, 3)} - ${humanReadableDate()}
-----------------------------`
    } else {
      header = `  - date: ${pubnubChangelogDate()}
    version: ${versionWithAdjustedComponentsCount(changelog.version!, 3)}
    changes:`
    }
  } else
    header = `${humanReadableDate()}
`

  for (let change of changelog.entries) {
    const addressedIssues = addressedIssuesCredits(change.addressedIssues, outputType == 'md', github)
    const type = changeTypeToHumanReadableType(change.type) as 'added' | 'fixed' | 'modified'
    let description = change.description || change.title
    if (description.endsWith('.'))
      description = description.slice(0, description.length - 1)
    if (change.isBreaking) description = `BREAKING CHANGES: ${description}`

    if (outputType == 'md')
      sections[type].push(`- ${capitalizedString(description)}. ${addressedIssues || ''}`.trim())
    else if (outputType == 'txt') {
      if (change.isBreaking) sections[type].push(`- ${description}. ${addressedIssues || ''}`.trim())
      else sections[type].push(`- ${capitalizedString(type)}: ${lowerCasedString(description)}. ${addressedIssues || ''}`.trim())
    } else
      sections[type].push(`      - type: ${humanReadableTypeToPubNubType(type)}
        text: "${capitalizedString(description)}."`)
  }

  for (const type of ['added', 'fixed', 'modified']) {
    // @ts-ignore
    if (sections[type].length) {
      // @ts-ignore
      const entries = sections[type].join('\n')

      if (outputType === 'txt') {
        body = `${body}${body.length > 0 ? '\n' : ''}${entries}
`
      }
      if (outputType === 'yml')
        body = `${body}${body.length > 0 ? '\n' : ''}${entries}`
      else if (outputType === 'md') {
        body = `${body}
#### ${capitalizedString(type)}
${entries}
`
      }
    }
  }

  if (outputType === 'md' || outputType === 'txt')
    return `${header}
${body}
`
  else
    return `${header}
${body}`
}

/**
 * Go through configured list of files and bump version there using specified match patterns.
 *
 * @param {string} version Version which should replace existing value.
 * @param {boolean} mainProduct Whether building change log for main product or not (main product stores `.pubnub.yml` in
 * repository root folder)
 * @param {string} rootDirectory Full path to location, where target repository root located.
 * @param {string|undefined} workingDirectory Full path to current product working directory.
 * @param {string|undefined} versions Content of `versions.json` file with match patterns.
 */
const bumpVersions = (
  version: string,
  mainProduct: boolean,
  rootDirectory: string,
  workingDirectory: string | undefined,
  versions: VersionsMatch | undefined
) => {
  if (!workingDirectory || !versions) return

  // Pre-process provided version.
  let versionInfo = versionComponents(version)

  for (let relativeFilePath of Object.keys(versions)) {
    const decidedWorkingDirectory = mainProduct && relativeFilePath.endsWith('.pubnub.yml') ? rootDirectory : workingDirectory
    const fullFilePath = path.join(decidedWorkingDirectory, relativeFilePath)

    // Ignore file if it is missing.
    if (!fs.existsSync(fullFilePath)) continue

    let content = fs.readFileSync(fullFilePath).toString('utf8')

    // Skip file if it is impossible to load it's content.
    if (!content) continue

    for (let versionMatcher of versions[relativeFilePath]) {
      const { cleared, clearedPrefix, clearedSuffix, versionComponents } = versionMatcher
      const re = new RegExp(versionMatcher.pattern, 'gm')
      let match

      while ((match = re.exec(content)) != null) {
        let targetVersion: string | null = versionWithAdjustedComponentsCount(versionInfo.version!, versionComponents)

        if (cleared === undefined || !cleared) {
          const { prefix, suffix } = versionInfo
          targetVersion = versionWithAdjustedComponentsCount(versionInfo.version!, versionComponents)
          let targetVersionComponents = [targetVersion]

          if (prefix && (clearedPrefix === undefined || !clearedPrefix))
            targetVersionComponents.unshift(prefix)
          if (suffix && (clearedSuffix === undefined || !clearedSuffix))
            targetVersionComponents.push(suffix)
          targetVersion = targetVersionComponents.join('')
        }

        const updated = match[0].replace(match[1], targetVersion!)
        content = replaceString(content, match[0], updated, match.index)
      }
    }

    fs.writeFileSync(fullFilePath, content)
  }
}

/**
 * Analyse generated changelog and decide on next release version.
 *
 * @param {string} currentVersion Version which currently used by product.
 * @param {Changelog} changelog List of changes which will be delivered.
 *
 * @return {string} Next version which is expected to be set according to semver practices.
 */
export const nextVersion = (currentVersion: string, changelog: Changelog): string => {
  let {prefix, version, suffix} = versionComponents(currentVersion)

  if (suffix && suffix.length) {
    const iterationMatch = suffix.match(/([0-9]+)$/mi)

    if (iterationMatch && iterationMatch.index && iterationMatch.index > 0) {
      const releaseType = suffix.substring(0, iterationMatch.index)
      const iteration = parseInt(suffix.substring(iterationMatch.index), 10)

      // Increasing iteration instead of semver fields.
      suffix = `${releaseType}${iteration + 1}`
    }
  } else {
    if (changelog.hasBreakingChanges && version) version = inc(version, 'major')
    else if (version) {
      const {entries} = changelog

      if (entries.filter(entry => minorChanges.includes(entry.type)).length)
        version = inc(version, 'minor')
      else if (entries.filter(entry => patchChanges.includes(entry.type)).length)
        version = inc(version, 'patch')
    }
  }

  return `${prefix ? prefix : ''}${version}${suffix ? suffix : ''}`
}

/**
 * Retry retrieve current product version number.
 *
 * @return {string|undefined} Version retrieved using `versions.json`.
 */
export const fetchCurrentVersion = (): string | undefined => {
  const decidedProductPath = productPath()
  let version: string | undefined

  if (decidedProductPath) {
    const relativeFilePath = '.pubnub.yml'
    const fullFilePath = path.join(process.env['GITHUB_WORKSPACE']!, decidedProductPath, relativeFilePath)

    if (fs.existsSync(fullFilePath)) {
      const fileContent = fs.readFileSync(fullFilePath).toString('utf8')
      if (fileContent) version = YAML.parse(fileContent).changelog[0].version
    }
  }

  return version
}

/**
 * Extract additional information from version.
 *
 * @param {string} fullVersion String with version which should be parsed.
 *
 * @return {VersionComponents} Information about cleared version and any prefix or suffix in it.
 */
export const versionComponents = (fullVersion: string): VersionComponents => {
  let prefix = fullVersion.startsWith('v') ? 'v' : undefined
  let version: string | null = fullVersion
  let suffix: string | undefined

  const nonReleaseMatch = fullVersion.match(/([a-zA-Z]+([0-9-.]+)?)$/)
  if (nonReleaseMatch && nonReleaseMatch.index && nonReleaseMatch.index > 0) {
    let suffixStartIndex = nonReleaseMatch.index

    if (['.', '-'].includes(fullVersion.charAt(suffixStartIndex-1))) suffixStartIndex--

    suffix = fullVersion.substring(suffixStartIndex)
    version = version.replace(suffix, '')
  }

  // Clean non-standard semver additions.
  const versionBeforeClean = version
  version = clean(versionBeforeClean)

  // Check whether handling non-standard semver version (with more than 3 components).
  if (!version && versionBeforeClean.split('.').length > 3) {
    version = versionBeforeClean

    if (prefix) version = version.replace(prefix, '')
    if (suffix) version = version.replace(suffix, '')
  }

  return { version, prefix, suffix }
}

/**
 * Load version bump configuration file.
 *
 * @return {VersionsMatch|undefined} Version bump configuration JSON.
 */
export const versionsJSON = (): VersionsMatch | undefined => {
  let versionsJSON: VersionsMatch | undefined
  const versionsPath = versionsJSONPath()

  if (versionsPath) {
    const versionsContent = fs.readFileSync(versionsPath).toString('utf8')
    if (versionsContent) versionsJSON = JSON.parse(versionsContent)
  }

  return versionsJSON
}

/**
 * Generate credits for users which pointed out on issue or suggested changes.
 *
 * @param {AddressedIssue[]} issues List of addressed issues and their authors.
 * @param {boolean} markdown Whether credits should be generated using Markdown markup or not.
 * @param {boolean} github Whether Markdown generated for GitHub release page or not.
 *
 * @return {string} Credits to issues / pull requests authors.
 */
const addressedIssuesCredits = (
  issues?: AddressedIssue[],
  markdown: boolean = false,
  github: boolean = false
): string | undefined => {
  let issuesList: { issues: string[]; pr: string[] } = {issues: [], pr: []}
  let usernames: { issues: string[]; pr: string[] } = {issues: [], pr: []}
  let addressedIssuesByTypes = []

  // Wrap GitHub username into link if required.
  const author = (id: string) =>
    markdown && !github ? `[@${id}](https://github.com/${id})` : `@${id}`
  // Wrap GitHub issue number into link if required.
  const issueId = (id: number, isPullRequest: boolean) =>
    markdown && !github
      ? `[#${id}](https://github.com/${action.repository.owner}/${
          action.repository.repo
        }/${isPullRequest ? 'pull' : 'issues'}/${id})`
      : `#${id}`

  for (let issue of issues ?? []) {
    const typeKey = issue.isPullRequest ? 'pr' : 'issues'
    if (issue.author) usernames[typeKey].push(author(issue.author))
    if (issue.issue) issuesList[typeKey].push(issueId(issue.issue, issue.isPullRequest))
  }

  // Truncate list of issue authors if it is longer than 5.
  Object.keys(usernames).forEach((typeKey: string) => {
    // @ts-ignore
    if (usernames[typeKey].length > 5) {
      // @ts-ignore
      usernames[typeKey].splice(5, usernames[typeKey].length - 5)
    }

    // @ts-ignore
    if (usernames[typeKey].length > 1) {
      // @ts-ignore
      usernames[typeKey] = [
        // @ts-ignore
        usernames[typeKey].slice(0, usernames[typeKey].length - 1).join(', '),
        // @ts-ignore
        usernames[typeKey].slice(usernames[typeKey].length - 1)[0]
      ]
    }
  })

  Object.keys(issuesList).forEach((typeKey: string) => {
    // @ts-ignore
    if (issuesList[typeKey].length > 1) {
      // @ts-ignore
      issuesList[typeKey] = [
        // @ts-ignore
        issuesList[typeKey].slice(0, issuesList[typeKey].length - 1).join(', '),
        // @ts-ignore
        issuesList[typeKey].slice(issuesList[typeKey].length - 1)[0]
      ]
    }
  })

  if (usernames.pr.length) {
    const prUsernames = usernames.pr.length > 1 ? usernames.pr.join(' and ') : usernames.pr[0]
    const prIssues = issuesList.pr.length > 1 ? issuesList.pr.join(' and ') : issuesList.pr[0]
    addressedIssuesByTypes.push(`Addresses the following PRs from ${prUsernames}: ${prIssues}.`)
  }

  if (usernames.issues.length) {
    const issueUsernames = usernames.issues.length > 1 ? usernames.issues.join(' and ') : usernames.issues[0]
    const issueIssues = issuesList.issues.length > 1 ? issuesList.issues.join(' and ') : issuesList.issues[0]
    addressedIssuesByTypes.push(`Fixed the following issues reported by ${issueUsernames}: ${issueIssues}.`)
  }

  return addressedIssuesByTypes.length ? addressedIssuesByTypes.join(' ') : undefined
}

/**
 * Convert user-provided change type to human-readable version.
 *
 * @param {string} type Initial value which should be converted.
 * @param {boolean} capitalized Whether returned value should start with capital or not.
 *
 * @return {string} Human-readable type version.
 */
const changeTypeToHumanReadableType = (type: string, capitalized: boolean = false): string => {
  if (['feature', 'feat'].includes(type)) type = 'added'
  else if (type === 'fix') type = 'fixed'
  else type = 'modified'

  return `${!capitalized ? type : capitalizedString(type)}`
}

/**
 * Convert human-readable change type to PubNub changelog version.
 *
 * @param {string} type Initial value which should be converted.
 *
 * @return {string} Type for PubNub changelog.
 */
const humanReadableTypeToPubNubType = (type: string): string => {
  if (type === 'added') return 'feature'
  else if (type === 'fixed') return 'bug'

  return 'improvement'
}

/**
 * Convert current date to PubNub changelog date format.
 *
 * @return {string} PubNub changelog date format.
 */
const pubnubChangelogDate = (): string =>
  new Date().toISOString().substring(0, 10)

/**
 * Convert current date to human-readable format with full month name.
 *
 * @return {string} Human-readable date.
 */
const humanReadableDate = (): string => {
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  const isoDateComponents = new Date().toISOString().substring(0, 10).split('-')
  const monthNumber = parseInt(isoDateComponents[1], 10)
  const month = months[monthNumber - 1]

  return `${capitalizedString(month)} ${isoDateComponents[2]} ${isoDateComponents[0]}`
}


/**
 * Adjust size of semver to required components count.
 *
 * @param {string | null} versionForAdjustment Semver which should be adjusted.
 * @param {number | undefined} expectedCount Expected length of semver in components.
 *
 * @return {string | null} Adjusted semver.
 */
const versionWithAdjustedComponentsCount = (versionForAdjustment: string, expectedCount: number | undefined): string | null => {
  let {version, prefix, suffix} = versionComponents(versionForAdjustment!)
  let targetVersion = versionForAdjustment

  if (expectedCount !== undefined && version && expectedCount < version!.split('.').length) {
    targetVersion = `${prefix ?? ''}${version!.split('.').slice(0, expectedCount).join('.')}${suffix ?? ''}`
  }

  return targetVersion
}
